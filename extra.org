
* DAG analysis'
** Basic DAG Analysis Utils

*** Utils

+BEGIN_SRC python :session :results output silent

ef testDAG(g):
   nx.write_adjlist(nx.DiGraph(g), './temp.txt')
   return nx.read_adjlist('./temp.txt', create_using=nx.DiGraph())

ef importReplicas(theorem_name):
   in_folder = './ProofDAGs/'+theorem_name+'/'
   orig = []
   replicas = []
   for f in os.listdir(in_folder):
       dag = nx.read_adjlist(in_folder+f,create_using=nx.DiGraph())
       if 'gen' in f:
           replicas.append(dag)
       else:
           orig.append(dag)
   assert(len(orig) == 1)
   return orig[0], replicas

ef nxToDict(graph):
   return {k:set(v) for k,v in nx.to_dict_of_lists(graph).items()}

ef importReplicasToDict(theorem_name):
   in_folder = './ProofDAGs/'+theorem_name+'/'
   orig = []
   replicas = []
   for f in os.listdir(in_folder):
       dag = nxToDict(nx.read_adjlist(in_folder+f,create_using=nx.DiGraph()))
       if 'gen' in f:
           replicas.append(dag)
       else:
           orig.append(dag)
   assert(len(orig) == 1)
   return orig[0], replicas


ef average(lst):
   return sum(lst) / len(lst)

ef dUnion(d1, d2):
   all_keys = set(d1.keys()).union(set(d2.keys()))
   out = dict()
   for k in all_keys:
       if k in d1:
           out[k] = d1[k]
       else:
           out[k] = d2[k]
   return out

ef findStrictMotifMatches(motif, dag):
   downgraph_nodes = map(lambda k: (k, nx.algorithms.descendants(dag, k)), dag.nodes_iter())
   downgraphs = map(lambda n: (n[0], nx.DiGraph(dUnion({n[0]:dag[n[0]]},
                                                       {x:dag[x] for x in n[1]}))),
                    downgraph_nodes)
   return set(map(lambda p: p[0],
                  filter(lambda x: nx.is_isomorphic(motif, x[1]),
                         downgraphs)))

ef createHist(lst):
   return list(map(lambda x: lst.count(x), range(max(lst)+1)))

ef createDAGHist(dag):
   return createHist(list(map(len, dag.adjacency_list())))

ef powerset(iterable):
   "powerset([1,2,3]) --> () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)"
   s = list(iterable)
   return itertools.chain.from_iterable(itertools.combinations(s, r) for r in range(len(s)+1))

ef findAllCombosOfNodesUnder(node, dag, size):
   out_node_lists = [[node]]
   count = 0
   while any(map(lambda x: len(x) != size, out_node_lists)):
       node_list = out_node_lists.pop(0)
       print(node_list)
       for child_combo in powerset(dag[node_list[-1]]):
           if len(node_list) < size:
               out_node_lists.append(node_list+list(child_combo))
           elif len(node_list) == size:
               out_node_lists.append(node_list)
       count += 1
       if count > 5: break
   return out_node_lists

+END_SRC

*** Partitioning Utils

+BEGIN_SRC python :session :results output silent

ef plotPartitions(G, partition, outfile):
   plt.figure()
   size = float(len(set(partition.values())))
   pos = nx.spring_layout(G)
   count = 0.
   for com in set(partition.values()) :
       list_nodes = [nodes for nodes in partition.keys()
                                   if partition[nodes] == com]
       nx.draw_networkx_nodes(G, pos, list_nodes, node_size = 20,
                                   node_color = str(count / size))
       count = count + 1.
   nx.draw_networkx_edges(G, pos, alpha=0.5)
   plt.savefig(outfile)

ef plotPartitionComparison(graphs, partitions, outfile, figsize=(6,4)):
   fig, axs = plt.subplots(1, 1, sharex = True, figsize=figsize)
   modularities = list(map(lambda G_part: community.modularity(G_part[1], G_part[0]),
                           zip(graphs, partitions)))
   axs.plot(range(len(modularities)), modularities, 'r+')
   axs.set_title('Modularity v Replica Count')
   axs.set_xlabel('Replica Count')
   axs.set_ylabel('Modularity')
   fig.tight_layout()
   plt.savefig(outfile)

ef theoremNameToPartitionOutfile(theorem_name):
   return './Images/'+theorem_name+'_partitions.png'

ef plotPartitionsFromTheoremName(theorem_name):
   outfile = theoremNameToPartitionOutfile(theorem_name)
   if not os.path.exists(outfile):
       orig, replicas = importReplicas(theorem_name)
       testDAG(orig)
       G = nx.Graph(orig)
       partition = community.best_partition(G)
       plotPartitions(nx.Graph(orig), partition, outfile)

ef theoremNameToModularitiesOutfile(theorem_name):
   return './Images/'+theorem_name+'_modularities.png'

ef plotModularitiesFromTheoremName(theorem_name):
   outfile = theoremNameToModularitiesOutfile(theorem_name)
   if not os.path.exists(outfile):
       orig, replicas = importReplicas(theorem_name)
       graphs = list(map(nx.Graph, [orig] + replicas))
       testDAG(graphs[0])
       partitions = list(map(community.best_partition, graphs))
       plotPartitionComparison(graphs, partitions, outfile)

+END_SRC

*** ev_8
**** Partition

+BEGIN_SRC python :session :results file
heorem_name = 'ev_8'
lotPartitionsFromTheoremName(theorem_name)
heoremNameToPartitionOutfile(theorem_name)
+END_SRC

+RESULTS:
[file:./Images/ev_8_partitions.png]]

**** Partition Replicas

+BEGIN_SRC python :session :results file
heorem_name = 'ev_8'
lotModularitiesFromTheoremName(theorem_name)
heoremNameToModularitiesOutfile(theorem_name)
+END_SRC

+RESULTS:
[file:./Images/ev_8_modularities.png]]

*** ev_8_alt
**** Partition

+BEGIN_SRC python :session :results file
heorem_name = 'ev_8_alt'
lotPartitionsFromTheoremName(theorem_name)
heoremNameToPartitionOutfile(theorem_name)
+END_SRC

+RESULTS:
[file:./Images/ev_8_alt_partitions.png]]

**** Partition Replicas

+BEGIN_SRC python :session :results file
heorem_name = 'ev_8_alt'
lotModularitiesFromTheoremName(theorem_name)
heoremNameToModularitiesOutfile(theorem_name)
+END_SRC

+RESULTS:
[file:./Images/ev_8_alt_modularities.png]]


+END_SRC

*** sqrt2_not_rational
**** Partition

+BEGIN_SRC python :session :results file
heorem_name = 'sqrt2_not_rational'
lotPartitionsFromTheoremName(theorem_name)
heoremNameToPartitionOutfile(theorem_name)
+END_SRC

+RESULTS:
[file:./Images/sqrt2_not_rational_partitions.png]]

**** Partition Replicas

+BEGIN_SRC python :session :results file
heorem_name = 'sqrt2_not_rational'
lotModularitiesFromTheoremName(theorem_name)
heoremNameToModularitiesOutfile(theorem_name)
+END_SRC

+RESULTS:
[file:./Images/sqrt2_not_rational_modularities.png]]


+END_SRC

** DAG Motif Finding

+BEGIN_SRC python :session :results output silent

ef countFeedForward(dag):
   count = 0
   for n in dag:
       children = dag[n]
       for ch in children:
           grandchildren = dag[ch]
           if any(children & grandchildren):
               #print(n)
               count += 1
   return count

ssert(countFeedForward(ev_8_dag) == 2)

ef getAllFeedForwardMatches(dag):
   matches = []
   for n in dag:
       children = dag[n]
       for child in children:
           grandchildren = dag[child]
           for grandchild in grandchildren:
               if grandchild in children:
                   matches.append({n,child,grandchild})
   return matches

ssert(getAllFeedForwardMatches(ev_8_dag)
      == [{'App1', 'App3', 'ev_SS'}, {'App2', 'App1', 'ev_SS'}])

ef hasCrossRefs(group_of_matches, dag):
   has_cross_refs = False
   for i in range(len(group_of_matches)):
       match, rest = group_of_matches[i], group_of_matches[:i] + group_of_matches[i+1:]
       match_children = set()
       for x in match:
           match_children = match_children | dag[x]
       rest_nodes = set()
       for y in rest:
           rest_nodes = rest_nodes | y
       if any(match_children & rest_nodes):
           return True
   return has_cross_refs

ssert(hasCrossRefs([{'App2','App1','ev_SS'},{'App3'}], ev_8_dag))
ssert(not hasCrossRefs([{'App2','App1','ev_SS'},{'2'}], ev_8_dag))

ef getLargestNonIntersectingGroup(matches, dag):
   largest_size = 0
   largest_group_of_matches = None
   for group_of_matches in powerset(matches):
       if group_of_matches:
           if len(group_of_matches) <= 1:
               is_overlapping = False
           else:
               is_overlapping = any(group_of_matches[0].intersection(*group_of_matches[1:]))
           if (not is_overlapping and not hasCrossRefs(group_of_matches, dag)
                                  and len(group_of_matches) > largest_size):
               largest_group_of_matches = group_of_matches
               largest_size = len(group_of_matches)
   return list(largest_group_of_matches) if largest_group_of_matches else []


ssert(
   getLargestNonIntersectingGroup(
       [{'App1', 'App3', 'ev_SS'}, {'App2', 'App1', 'ev_SS'}], ev_8_dag) ==
   [{'App3', 'App1', 'ev_SS'}])

ef removeGroupOfMatches(group_of_matches, dag):
   previous_motif_nodes = list(filter(lambda x: x[:6] == 'motif_', dag))
   if previous_motif_nodes:
       max_previous_motif_num = max(map(lambda y: int(y[6:]), previous_motif_nodes))
   else:
       max_previous_motif_num = 0
   new_motif_name = 'motif_' + str(max_previous_motif_num)
   new_dag = dag.copy()
   for match in group_of_matches:
       new_motif_name = new_motif_name[:6] + str(int(new_motif_name[6:])+1)
       new_dag[new_motif_name] = set()
       for node in dag:
           if any(dag[node] & match):
               new_dag[node] = (dag[node] - match) | {new_motif_name}
           if node in match:
               new_dag[new_motif_name] = new_dag[new_motif_name] | (dag[node] - match)
               del new_dag[node]
   return new_dag

ef removeMatch(match, dag):
   previous_motif_nodes = list(filter(lambda x: x[:6] == 'motif_', dag))
   if previous_motif_nodes:
       max_previous_motif_num = max(map(lambda y: int(y[6:]), previous_motif_nodes))
   else:
       max_previous_motif_num = 0
   new_motif_name = 'motif_' + str(max_previous_motif_num)
   new_dag = dag.copy()
   new_motif_name = new_motif_name[:6] + str(int(new_motif_name[6:])+1)
   new_dag[new_motif_name] = set()
   for node in dag:
       if any(dag[node] & match):
           new_dag[node] = (dag[node] - match) | {new_motif_name}
       if node in match:
           new_dag[new_motif_name] = new_dag[new_motif_name] | (dag[node] - match)
           del new_dag[node]
   return new_dag

ssert(
   removeGroupOfMatches([{'App3', 'App1', 'ev_SS'}], ev_8_dag) ==
   {'6': set(), '4': set(), 'App2': {'6', 'motif_1'}, '2': set(),
    'ev_8.ev_2': set(), 'motif_1': {'ev_8.ev_2', '2', '4'}})

ef compressDAG(dag, repeat=1):
   new_dag = dag.copy()
   for _ in range(repeat):
       matches = getAllFeedForwardMatches(new_dag)
       #print("matches", matches)
       if matches:
           match = list(matches)[0]
           new_dag = removeMatch(match, new_dag)
       #group_of_matches = getLargestNonIntersectingGroup(matches, new_dag)
       #print("g of matches", group_of_matches)
       #if group_of_matches:
       #    new_dag = removeGroupOfMatches(group_of_matches, new_dag)
   return new_dag

ef getCompressedDAGSizes(dag,repeat=1, theorem_name=None):
   new_dag = dag.copy()
   sizes = [len(new_dag)]
   for i in range(repeat):
       matches = getAllFeedForwardMatches(new_dag)
       if matches:
           match = list(matches)[0]
           new_dag = removeMatch(match, new_dag)
       sizes.append(len(new_dag))
       if theorem_name:
           plotGraph(nx.DiGraph(new_dag),
                               './Images/'+theorem_name+'_dag_compressed_'+str(i+1),
                               label=True)
   return sizes


ef getCompressedDAGs(dag, repeat=1):
   new_dag = dag.copy()
   out_dags = [dag.copy()]
   for i in range(repeat):
       matches = getAllFeedForwardMatches(new_dag)
       print('hi',matches)
       if matches:
           match = list(matches)[0]
           new_dag = removeMatch(match, new_dag)
       out_dags.append(new_dag.copy())
   return out_dags

ef getNumMotifs(dag, repeat=1, check_dag=False, theorem_name=None):
     new_dag = dag.copy()
     num_motifs = []
     print('0', nx.is_directed_acyclic_graph(nx.DiGraph(dag)))
     for i in range(repeat):
         matches = getAllFeedForwardMatches(new_dag)
         num_motifs.append(len(matches))
         if matches:
             match = list(matches)[0]
             new_dag = removeMatch(match, new_dag)
         if check_dag:
             print(str(i+1), nx.is_directed_acyclic_graph(nx.DiGraph(new_dag)))
         if theorem_name:
             plotGraph(nx.DiGraph(new_dag),
                               './Images/'+theorem_name+'_dag_compressed_'+str(i+1),
                               label=True)
     return num_motifs

+END_SRC

** Plot DAG motif finding and removal
*** ev_8

+BEGIN_SRC python :session :results file
utfile = 'Images/ev_8_dag_compressed.png'
ew_dag = compressDAG(ev_8_dag)
lotGraph(nx.DiGraph(new_dag), outfile, label=True)
utfile
+END_SRC

+RESULTS:
[file:Images/ev_8_dag_compressed.png]]

+BEGIN_SRC python :session :results file
utfile = 'Images/ev_8_mod_dag_compressed.png'
v_8_dag_mod = ev_8_dag.copy()
v_8_dag_mod['2'] = {'ev_8.ev_2'}
ew_dag = compressDAG(ev_8_dag_mod, repeat=2)
lotGraph(nx.DiGraph(new_dag), outfile, label=True)
utfile
+END_SRC

+RESULTS:
[file:Images/ev_8_mod_dag_compressed.png]]

*** ev_8_alt

+BEGIN_SRC python :session :results file
utfile = 'Images/ev_8_alt_dag_compressed.png'
ew_dag = compressDAG(toplistToDAG(utils.ev_8_alt_tree))
lotGraph(nx.DiGraph(new_dag), outfile, label=True)
utfile
+END_SRC

+RESULTS:
[file:Images/ev_8_alt_dag_compressed.png]]

+BEGIN_SRC python :session :results file
utfile = 'Images/ev_8_alt_dag_compressed_2.png'
ew_dag = compressDAG(toplistToDAG(utils.ev_8_alt_tree),repeat=2)
lotGraph(nx.DiGraph(new_dag), outfile, label=True)
utfile
+END_SRC

+RESULTS:
[file:Images/ev_8_alt_dag_compressed_2.png]]

** Plot size v num compressions
*** ev_8
**** Original

+BEGIN_SRC python :session :results file
utfile = 'Images/ev_8_dag_compression_comparison.png'
izes = getCompressedDAGSizes(ev_8_dag, repeat=3, theorem_name='ev_8')
lotLineGraph(sizes, outfile)
utfile
+END_SRC

+RESULTS:
[file:Images/ev_8_dag_compression_comparison.png]]

*** ev_8_alt
**** Original

+BEGIN_SRC python :session :results file
utfile = 'Images/ev_8_alt_dag_compression_comparison.png'
ag = toplistToDAG(utils.ev_8_alt_tree)
izes = getCompressedDAGSizes(dag, repeat=5, theorem_name='ev_8_alt')
lotLineGraph(sizes, outfile)
utfile
+END_SRC

+RESULTS:
[file:Images/ev_8_alt_dag_compression_comparison.png]]

**** Replica

+BEGIN_SRC python :session :results file
utfile = 'Images/ev_8_alt_gen_dag_compression_comparison.png'
rig, replicas = importReplicasToDict('ev_8_alt')
izes = [getCompressedDAGSizes(replica, repeat=5, theorem_name='ev_8_alt')
          for replica in [orig]+replicas[:3]]
rint(sizes)
lotLineGraphs(sizes, outfile)
utfile
+END_SRC

+RESULTS:
[file:Images/ev_8_alt_gen_dag_compression_comparison.png]]

*** factorial

otice that there are no cycles here despite the recursion

+BEGIN_SRC python :session :results file
utfile = 'Images/factorial_dag.png'
act_string = "(Top (Definition Top.fact (Fix (Functions (App fact 0 (Prod n nat nat) (Lambda n nat (Case 0 (Lambda n nat nat) (CaseMatch n) (CaseBranches (App S O) (Lambda n' nat (App Coq.Init.Nat.mul n (App fact n')))))))) 0)))"
act_tree = utils.parenStringToLists(fact_string)
act_dag = toplistToDAG(fact_tree)
lotGraph(nx.DiGraph(fact_dag), outfile, label=True)
utfile
+END_SRC

+RESULTS:
[file:Images/factorial_dag.png]]

 don't believe I can create a cycle on the first pass, but unsure.
ry compression until cycle creation.

+BEGIN_SRC python :session :results file
utfile = 'Images/factorial_repeat_motif.png'
ags = getCompressedDAGs(fact_dag, repeat=2)
lotGraphList([nx.DiGraph(x) for x in dags], outfile, label=True)
utfile
+END_SRC

+RESULTS:
[file:Images/factorial_repeat_motif.png]]

+BEGIN_SRC python :session :results file
utfile = 'Images/factorial_num_motifs.png'
izes = getNumMotifs(fact_dag, repeat=4)
lotLineGraph(sizes, outfile)
utfile
+END_SRC

+RESULTS:
[file:Images/factorial_num_motifs.png]]

uch higher average stopping point.

+BEGIN_SRC python :session :results file
utfile = 'Images/factorial_gen_num_motifs.png'
izes = getNumMotifs(genComparableGraph(fact_dag), repeat=8)
lotLineGraph(sizes, outfile)
utfile
+END_SRC

+RESULTS:
[file:Images/factorial_gen_num_motifs.png]]

*** forward

+BEGIN_SRC python :session :results file
utfile = 'Images/forward_dag.png'
orward_string = "(Top (Definition Top.forward (Lambda f (Prod Anonymous (App prod (Axiom Top.A) (Axiom Top.B)) (Axiom Top.C)) (Lambda a (Axiom Top.A) (Lambda b (Axiom Top.B) (Cast (Cast (App eq_refl (Axiom Top.C) (App f (App pair (Axiom Top.A) (Axiom Top.B) a b))) REVERTcast (App eq (Axiom Top.C) (App f (App pair (Axiom Top.A) (Axiom Top.B) (App Coq.Init.Datatypes.fst (Axiom Top.A) (Axiom Top.B) (App pair (Axiom Top.A) (Axiom Top.B) a b)) (App Coq.Init.Datatypes.snd (Axiom Top.A) (Axiom Top.B) (App pair (Axiom Top.A) (Axiom Top.B) a b)))) (App f (App pair (Axiom Top.A) (Axiom Top.B) a b)))) REVERTcast (App eq (Axiom Top.C) (App Top.uncurry (App Top.curry f) (App pair (Axiom Top.A) (Axiom Top.B) a b)) (App f (App pair (Axiom Top.A) (Axiom Top.B) a b)))))))))"
orward_tree = utils.parenStringToLists(forward_string)
orward_dag = toplistToDAG(forward_tree)
lotGraph(nx.DiGraph(forward_dag), outfile, label=True)
utfile
+END_SRC

+RESULTS:
[file:Images/forward_dag.png]]

+BEGIN_SRC python :session :results file
utfile = 'Images/forward_num_motifs.png'
izes = getNumMotifs(forward_dag, repeat=15)
lotLineGraph(sizes, outfile)
utfile
+END_SRC

+RESULTS:
[file:Images/forward_num_motifs.png]]


imilar average stopping point for random

+BEGIN_SRC python :session :results file
utfile = 'Images/forward_gen_num_motifs.png'
izes = getNumMotifs(genComparableGraph(forward_dag), repeat=15)
lotLineGraph(sizes, outfile)
utfile
+END_SRC

+RESULTS:
[file:Images/forward_gen_num_motifs.png]]



+BEGIN_SRC python :session :results file
utfile = 'Images/forward_repeat_motif.png'
ags = getCompressedDAGs(forward_dag, repeat=3)
lotGraphList([nx.DiGraph(x) for x in dags], outfile, label=True)
utfile
+END_SRC

+RESULTS:
[file:Images/forward_repeat_motif.png]]

*** currying

**** Plot DAG

+BEGIN_SRC python :session :results file
utfile = 'Images/curry_dag.png'
urry_string = "(Top (Definition Top.curry (Lambda f (Prod Anonymous (App prod (Axiom Top.A) (Axiom Top.B)) (Axiom Top.C)) (Lambda a (Axiom Top.A) (Lambda b (Axiom Top.B) (App f (App pair (Axiom Top.A) (Axiom Top.B) a b)))))))"
urry_tree = utils.parenStringToLists(curry_string)
urry_dag = toplistToDAG(curry_tree)
lotGraph(nx.DiGraph(curry_dag), outfile, label=True)
utfile
+END_SRC

+RESULTS:
[file:Images/curry_dag.png]]

**** Plot num motifs

+BEGIN_SRC python :session :results file
utfile = 'Images/curry_num_motifs.png'
izes = getNumMotifs(curry_dag, repeat=5)
lotLineGraph(sizes, outfile)
utfile
+END_SRC

+RESULTS:
[file:Images/curry_num_motifs.png]]

**** Plot num motifs of replica

+BEGIN_SRC python :session :results file
utfile = 'Images/curry_gen_num_motifs.png'
izes = getNumMotifs(genComparableGraph(curry_dag), repeat=5)
lotLineGraph(sizes, outfile)
utfile
+END_SRC

+RESULTS:
[file:Images/curry_gen_num_motifs.png]]

** Test hypo that more cycles in theorem version
*** dec inc

here are more in the theorem case, but hard to say if that is just because of the size.

+BEGIN_SRC python :session :results file
utfile = 'Images/dec_inc_dag.png'
ec_inc_string = "(Top (Definition Top.dec_inc (Lambda nat (App Top.dec (App S gen_var_2)))))"
ec_inc_tree = utils.parenStringToLists(dec_inc_string)
ec_inc_dag = toplistToDAG(dec_inc_tree)
rint(dec_inc_dag)
lotGraph(nx.DiGraph(dec_inc_dag), outfile, label=True)
utfile
+END_SRC

+RESULTS:
[file:Images/dec_inc_dag.png]]

+BEGIN_SRC python :session :results file
utfile = 'Images/dec_inc_num_motifs.png'
izes = getNumMotifs(dec_inc_dag, repeat=10, theorem_name='dec_inc')
lotLineGraph(sizes, outfile)
utfile
+END_SRC

+RESULTS:
[file:Images/dec_inc_num_motifs.png]]

*** dec inc prop

+BEGIN_SRC python :session :results file
utfile = 'Images/dec_inc_prop_dag.png'
ec_inc_prop_string = "(Top (Definition Top.dec_inc_prop (Lambda nat (App eq_refl nat gen_var_1))))"
ec_inc_prop_tree = utils.parenStringToLists(dec_inc_prop_string)
ec_inc_prop_dag = toplistToDAG(dec_inc_prop_tree)
rint(dec_inc_prop_dag)
lotGraph(nx.DiGraph(dec_inc_prop_dag), outfile, label=True)
utfile
+END_SRC

+RESULTS:
[file:Images/dec_inc_prop_dag.png]]

+BEGIN_SRC python :session :results file
utfile = 'Images/dec_inc_prop_num_motifs.png'
izes = getNumMotifs(dec_inc_prop_dag, repeat=12)
lotLineGraph(sizes, outfile)
utfile
+END_SRC

+RESULTS:
[file:Images/dec_inc_prop_num_motifs.png]]

eBruijin is not quite what we are looking for -- is replacing the names inside of the body,
but we want global names that can be pointed to
his global unique thing is different from alpha renaming
lso a sort of preemptive alpha renaming and only of closed terms

eep a dictionary during parse, which is passed around with replacement names
o not pass around, because variable names will incremement in levels -- can get several diff at same level with same name
odify global dictionary

hould I keep a dictionary of names of strings?
f names then I will be able to plug and play in curry use of names

uild_lambda
uild_prod
uild_let_in
uild_fix_fun
uild_inductive_name

** Check num direct loops
**** Count cycles

#+BEGIN_SRC python :session :results output silent

def countCycles(dag):
    count = 0
    for n in dag:
        children = dag[n]
        for ch in children:
            grandchildren = dag[ch]
            if n in grandchildren:
                #print(n)
                count += 1
    return count

def getAllCycles(dag):
    matches = []
    for n in dag:
        children = dag[n]
        for child in children:
            grandchildren = dag[child]
            if n in grandchildren:
                matches.append({n,child})
    return matches


def getNumCycles(dag, repeat=1, check_dag=True, theorem_name=None):
      new_dag = dag.copy()
      num_motifs = []
      num_cycles = []
      print('0', nx.is_directed_acyclic_graph(nx.DiGraph(dag)))
      for i in range(repeat):
          matches = getAllFeedForwardMatches(new_dag)
          num_motifs.append(len(matches))
          num_cycles.append(countCycles(new_dag)/2)
          if matches:
              match = list(matches)[0]
              new_dag = removeMatch(match, new_dag)
          if check_dag:
              print(str(i+1), nx.is_directed_acyclic_graph(nx.DiGraph(new_dag)))
          if theorem_name:
              plotGraph(nx.DiGraph(new_dag),
                                './Images/'+theorem_name+'_dag_compressed_'+str(i+1),
                                label=True)
      return num_motifs, num_cycles

#+END_SRC

#+BEGIN_SRC python :session :results file
outfile = 'Images/dec_inc_num_cycles.png'
num_motifs, num_cycles = getNumCycles(dec_inc_dag, repeat=10)
plotLineGraphs([num_motifs, num_cycles], outfile)
outfile
#+END_SRC

#+RESULTS:
[[file:Images/dec_inc_num_cycles.png]]

**** sqrt2_not_rational

#+BEGIN_SRC python :session :results file
theorem_name = 'sqrt2_not_rational'
outfile = 'Images/'+theorem_name+'_num_cycles.png'
sqrt2_dag = toplistToDAG(utils.sqrt2_tree, 'sqrt2_not_rational')
motifs_and_cycles = getNumCycles(sqrt2_dag, check_dag = False, repeat=400)
plotLineGraphs(motifs_and_cycles, outfile)
outfile
#+END_SRC

#+RESULTS:
[[file:Images/sqrt2_not_rational_num_cycles.png]]
[[file:Images/sqrt2_not_rational_gen_num_cycles.png]]

**** sqrt2_not_rational_d3

#+BEGIN_SRC python :session :results file
theorem_name = 'sqrt2_not_rational_d3'
outfile = 'Images/'+theorem_name+'_num_cycles.png'
#sqrt2_d3_dag = toplistToDAG(sqrt2_d3_tree)
#motifs_and_cycles = getNumCycles(sqrt2_d3_dag, check_dag = False, repeat=1500)
#plotLineGraphs(motifs_and_cycles, outfile)
outfile
#+END_SRC

#+RESULTS:
[[file:Images/sqrt2_not_rational_d3_num_cycles.png]]

**** sqrt2_not_rational_d4

#+BEGIN_SRC python :session :results file
theorem_name = 'sqrt2_not_rational_d4'
outfile = 'Images/'+theorem_name'_num_cycles.png'
#sqrt2_d4_tree = utils.theoremNameToLists('sqrt2_not_rational',depth=4)
#sqrt2_d4_dag = toplistToDAG(sqrt2_d4_tree)
#motifs_and_cycles = getNumCycles(sqrt2_d4_dag, check_dag = False, repeat=2000)
#plotLineGraphs(motifs_and_cycles, outfile)
outfile
#+END_SRC

#+RESULTS:
[[file:Images/sqrt2_not_rational_d3_num_cycles.png]]



**** nat equality

#+BEGIN_SRC python :session :results file
outfile = 'Images/eq_dag.png'
eq_string = "(Top (Definition Top.eq_nat (Lambda nat (App Coq.Init.Datatypes.nat_ind (Lambda nat (App eq nat gen_var_3 gen_var_3)) (App eq_refl nat O) (Lambda nat (Lambda (App eq nat gen_var_4 gen_var_4) (App eq_refl nat (App S gen_var_4)))) gen_var_4))))"
eq_tree = utils.parenStringToLists(eq_string)
eq_dag = toplistToDAG(eq_tree)
plotGraph(nx.DiGraph(eq_dag), outfile, label=True)
outfile
#+END_SRC

#+RESULTS:
[[file:Images/eq_dag.png]]



#+BEGIN_SRC python :session :results file
outfile = 'Images/eq_num_cycles.png'
sizes = getNumCycles(eq_dag, theorem_name='eq', repeat=15)
plotLineGraphs(sizes, outfile)
outfile
#+END_SRC

#+RESULTS:
[[file:Images/eq_num_cycles.png]]
