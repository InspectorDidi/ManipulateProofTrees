#+TITLE: Manipulate Proof Trees
#+OPTIONS: tex:t
#+STARTUP: latexpreview
#+LATEX_HEADER: \usepackage{qtree,tiks}


* Manip Proof Trees

** Imports

#+BEGIN_SRC python :session :results output silent

import utils
import math
import copy
import itertools
import pickle
import ast
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
import json
import functools
import pdb
import cProfile
import subprocess
import networkx as nx
import os
import random
import re
import community
from scipy.special import digamma
from scipy.optimize import fsolve

#+END_SRC

** Create theorem dags from unsubbed representations

*** Convert individual theorem tree to graph

#+BEGIN_SRC python :session :results output silent

cic_constructors = ['App', 'Definition', 'Axiom', 'Lambda',
                    'Cast', 'LetIn','Fix','CoFix',
                    'CaseMatch', 'CaseBranches','Sort',
                    'Prod','Inductive','Case','CoInductive',
                    'Record','VMCast','DEFAULTcast','REVERTcast',
                    'NATIVEcast','Var','Meta','Evar','Rel','Level',
                    'Max','Universe','UnivInstance','Sort','Prop','Type',
                    'Functions','Proj','Name','Anonymous']

def constructorMatch(test, constructor):
    return constructor == test[:len(constructor)]

assert(constructorMatch('App1','App'))
assert(not constructorMatch('App','App1'))

cic_regex = re.compile("^"+"|".join(cic_constructors))
def isConstructor(test):
    return bool(cic_regex.match(test))

assert(isConstructor('App1'))
assert(isConstructor('Lambda2'))
assert(isConstructor('Cast'))

def isShallowSubgraph(dag1, dag2):
    constructor, children = next(iter(dag1.items()))
    for k2 in dag2:
        if constructorMatch(k2, constructor) and children == dag2[k2]:
            return k2
    return False

assert(isShallowSubgraph({'App': {'1','2'}}, {'App1':{'1','2'}}) == 'App1')
assert(not isShallowSubgraph({'App':{'1','2'}}, {'App1':{'1','3'}}))

#+END_SRC


#+BEGIN_SRC python :session :results output

def listToDAGHelper(tree, out_dag, cic_count):
    if not isinstance(tree, list):
        out_dag[tree] = set()
        return out_dag, tree, cic_count
    else:
       root, children = tree[0], tree[1:]
       mod_child_names = []
       for child in children:
           out_dag, name, cic_count = listToDAGHelper(child, out_dag, cic_count)
           mod_child_names.append(name)
       new_dag = {root: set(mod_child_names)}
       root_new = isShallowSubgraph(new_dag, out_dag)
       if not root_new:
           cic_count[root] += 1
           root_new = root + str(cic_count[root])
           out_dag[root_new] = set(mod_child_names)
    return out_dag, root_new, cic_count

def listToDAG(tree):
    return listToDAGHelper(tree, {}, {constr: 0 for constr in cic_constructors})

def checkEq(d1, d2):
    if d1.keys() != d2.keys():
        return False
    for k in d1:
        if d1[k] != d2[k]: return False
    return True


a = ['App','2','2']
b = ['App','2',a]
c = ['App',b,b]

#utils.ev_4_tree = utils.theoremNameToLists('ev_4', depth=2)

# did we want this (App3)?
assert(checkEq(listToDAG(c)[0],
               {'2': set(), 'App1': {'2'}, 'App2': {'2', 'App1'}, 'App3': {'App2'}}))

assert(checkEq(
        listToDAG(utils.ev_4_tree[1][2])[0],
        {'ev_SS': set(), '2': set(), 'ExportProof.ev_2': set(), 'App1': set(['ev_SS', '2', 'ExportProof.ev_2'])}))

assert(checkEq(listToDAG(['App',['App','2','2'],['App','2','2']])[0],
               {'2': set(), 'App1': {'2'}, 'App2': {'App1'}}))

assert(checkEq(
        listToDAG(['App', ['App', '2', '2'], ['App', '2', ['App', '2', '2']]])[0],
        {'2': set(), 'App1': {'2'}, 'App2': {'App1', '2'}, 'App3': {'App2', 'App1'}}
       ))

#+END_SRC

#+RESULTS:

*** Convert multiple theorems to DAG

#+BEGIN_SRC python :session :results output silent

def toplistToDAG(top_level_theorem, depth=2):
    dag = {}
    cic_count = {constr: 0 for constr in cic_constructors}
    count = 0
    for tree in top_level_theorem[1:]:
        lemma_name, lemma_def = tree[1], tree[2]
        dag, lemma_root, cic_count = listToDAGHelper(lemma_def, dag.copy(), cic_count.copy())
        if count >= 1:
            dag.pop(lemma_name, None)
            for k,v in dag.items():
                if lemma_name in v:
                    dag[k] = {x if x != lemma_name else lemma_root for x in v}
        else:
            theorem_name = lemma_name
        count += 1
    return dag

assert(toplistToDAG(utils.ev_4_tree)
        == {'ev_SS': set(), '2': set(), 'App1': {'2', 'App2', 'ev_SS'}, 'O': set(),
            'ev_0': set(), 'App2': {'ev_0', 'O', 'ev_SS'}})

#+END_SRC

*** Convert library to DAG

#+BEGIN_SRC python :session :results output silent

def libNameToDAG(library_name, depth=2, mod_libs=False, limit=None):
    theorem_dict = utils.libNameToTheoremDict(library_name, depth=depth, mod_libs=mod_libs, limit=limit)
    theorem_tree = ['Top'] + list(map(lambda x:x[1], theorem_dict.values()))
    library_dag = toplistToDAG(theorem_tree)
    return library_dag

#+END_SRC

*** Plot graph utils

#+BEGIN_SRC python :session :results output silent

def plotGraph(graph, outfile, label=False, figsize=(4,4)):
    assert(graph.order() != 0)
    plt.figure(figsize=figsize)
    nx.spring_layout(graph, k=5/math.sqrt(graph.order()))
    nx.draw(graph, with_labels=label, node_size = 50)
    l,r = plt.xlim()
    plt.xlim(l-.2,r+.2)
    plt.savefig(outfile)

def plotUndirected(graph, outfile, label=False, figsize=(4,4)):
    undir_graph = nx.Graph(graph)
    plt.figure(figsize=figsize)
    nx.spring_layout(undir_graph, k=5/math.sqrt(undir_graph.order()))
    nx.draw(undir_graph, with_labels=label, node_size = 20)
    l,r = plt.xlim()
    plt.xlim(l-.2,r+.2)
    plt.savefig(outfile)


def plotGraphs(g1, g2, outfile, label=False, figsize=(4,4)):
    fig, axs = plt.subplots(1,2,figsize=figsize)
    nx.spring_layout(g1, k=5/math.sqrt(g1.order()))
    nx.draw(g1, ax=axs[0], with_labels=label, node_size = 50)
    nx.spring_layout(g2, k=5/math.sqrt(g2.order()))
    nx.draw(g2, ax=axs[1], with_labels=label, node_size = 50)
    range1,range2 = axs[0].get_xlim(), axs[1].get_xlim()
    axs[0].set_xlim(range1[0]-0.2, range1[1]+0.2)
    axs[1].set_xlim(range2[0]-0.2, range2[1]+0.2)
    plt.savefig(outfile)


#+END_SRC

*** Plot theorem DAG's
**** ev_4

#+BEGIN_SRC python :session :results file
theorem_name = 'ev_4'
g = nx.DiGraph(toplistToDAG(utils.ev_4_tree))
plotGraph(g,'./Images/'+theorem_name+'_DAG.png',label=True)
'./Images/'+theorem_name+'_DAG.png'
#+END_SRC

#+RESULTS:
[[file:./Images/ev_4_DAG.png]]

**** ev_8

#+BEGIN_SRC python :session :results file
theorem_name = 'ev_8'
g = nx.DiGraph(toplistToDAG(utils.ev_8_tree))
outfile = './Images/'+theorem_name+'_DAG.png'
plotGraph(g, outfile, label=True)
outfile
#+END_SRC

#+RESULTS:
[[file:./Images/ev_8_DAG.png]]

**** sqrt2_not_rational
***** With libraries

#+BEGIN_SRC python :session :results file
theorem_name, depth, mod_libs = 'sqrt2_not_rational', 2, False
#outfile = './Images/'+theorem_name+'_d'+str(depth)+('_mod_DAG.png' if mod_libs else '_DAG.png')
#tree = utils.theoremNameToLists(theorem_name, depth=depth, mod_libs=mod_libs)
#dag = toplistToDAG(tree)
#plotGraph(nx.DiGraph(dag), outfile, label=True, figsize=(8,8))
outfile
#+END_SRC

#+RESULTS:
[[file:./Images/ev_8_DAG.png]]

***** Without libraries

#+BEGIN_SRC python :session :results file
theorem_name, depth, mod_libs = 'sqrt2_not_rational', 2, True
outfile = './Images/'+theorem_name+'_d'+str(depth)+('_mod_DAG.png' if mod_libs else '_DAG.png')
tree = utils.theoremNameToLists(theorem_name, depth=depth, mod_libs=mod_libs)
dag = toplistToDAG(tree)
plotGraph(nx.DiGraph(dag), outfile, label=True, figsize=(8,8))
outfile
#+END_SRC

#+RESULTS:
[[file:./Images/sqrt2_not_rational_d2_mod_DAG.png]]


**** birthday_paradox

#+BEGIN_SRC python :session :results file
theorem_name = 'birthday_paradox'
outfile = './Images/'+theorem_name+'_DAG.png'
#bday_tree = utils.theoremNameToLists('birthday_paradox', depth=2)
#bday_dag = toplistToDAG(bday_tree, theorem_name)
#plotGraph(nx.DiGraph(bday_dag), outfile, label=False, figsize=(8,8))
'./Images/'+theorem_name+'_DAG.png'
#+END_SRC

#+RESULTS:
[[file:./Images/birthday_paradox_DAG.png]]

**** Pythagorean Theorem

#+BEGIN_SRC python :session :results file
theorem_name, depth = 'pythagoras', 1
outfile = './Images/'+theorem_name+'_DAG.png'
#dag = toplistToDAG(utils.theoremNameToLists(theorem_name, depth))
#plotGraph(nx.DiGraph(dag), outfile, label=True, figsize=(8,8))
'./Images/'+theorem_name+'_DAG.png'
#+END_SRC

#+RESULTS:
[[file:./Images/pythagoras_DAG.png]]


** Generate random DAG's with same degree distribution

*** Generate random replica DAG's with same arities

#+BEGIN_SRC python :session :results output silent

ev_4_dag = toplistToDAG(utils.ev_4_tree)
ev_8_dag = toplistToDAG(utils.ev_8_tree)

def anyIncomingEdges(node, graph):
    return any([node in v for v in graph.values()])

def randomTopSortSlow(theorem_dag):
    dag = copy.deepcopy(theorem_dag)
    L = []
    S = {k for k in dag if not anyIncomingEdges(k, dag)}
    while S:
        n = S.pop()
        L.append(n)
        neighbors = dag[n].copy()
        for m in random.sample(neighbors, len(neighbors)):
            dag[n].remove(m)
            if not anyIncomingEdges(m, dag):
                S.add(m)
    return L

def checkDictClosed(d):
    for k in d:
        for v in d[k]:
            if v not in d: return False
    return True

def getDictClosure(d):
    out = []
    for k in d:
        for v in d[k]:
            if v not in d:
                out.append(v)
    return out


def getNodeIndegrees(theorem_dag):
    indegrees = {k:0 for k in theorem_dag}
    for k in theorem_dag:
        for v in theorem_dag[k]:
            indegrees[v] += 1
    return indegrees

def getNodeOutdegrees(dag):
    return {k:len(v) for k,v in dag.items()}

def randomTopSort(theorem_dag):
    dag = copy.deepcopy(theorem_dag)
    L = []
    indegree_dict = getNodeIndegrees(dag)
    S = {k for k in indegree_dict if indegree_dict[k] == 0}
    while S:
        n = S.pop()
        L.append(n)
        neighbors = dag[n].copy()
        for m in random.sample(neighbors, len(neighbors)):
            dag[n].remove(m)
            indegree_dict[m] -= 1
            if indegree_dict[m] == 0: #anyIncomingEdges(m, dag):
                S.add(m)
    return L


def getDownStream(node, graph):
    out = []
    frontier = [node]
    while frontier:
        current_node = frontier.pop(0)
        out.append(current_node)
        frontier.extend(list(graph[current_node]))
    return out


def checkTopOrder(top_order, graph):
    collective_downstream = set()
    for current_node in top_order[::-1]:
        if current_node in collective_downstream:
            return False
        collective_downstream = collective_downstream.union(getDownStream(current_node, graph))
    return True

#assert(checkTopOrder(nx.topological_sort(nx.DiGraph(ev_8_dag)), ev_8_dag))
#assert(all([checkTopOrder(randomTopSort(ev_8_dag), ev_8_dag) for _ in range(100)]))


def flatten(lst_of_lsts):
    return functools.reduce(lambda x,y: x+y, lst_of_lsts, [])

def genComparableGraph(theorem_dag, test=False):
    #preprocessing
    theorem_nodes = list(theorem_dag.keys())
    name_to_num = {name: num for num, name in enumerate(theorem_nodes)}
    num_to_name = {num: name for num, name in enumerate(theorem_nodes)}
    outgoing_edges = {n: len(theorem_dag[num_to_name[n]])
                         for n in range(len(theorem_nodes))}
    #create random connections that match arities
    top_sort = randomTopSort(theorem_dag)
    if test:
        assert(checkTopOrder(top_sort, theorem_dag)) #errors in here
        assert(outgoing_edges[name_to_num[top_sort[-1]]] == 0)
    new_nodes = [name_to_num[name] for name in top_sort]
    new_graph = {n:set() for n in range(len(theorem_nodes))}
    #first pass
    for i in range(1,len(new_nodes)):
        current_node = new_nodes[i]
        connection_options = flatten([[(parent, edge) for edge in range(outgoing_edges[parent])]
                                        for parent in new_nodes[:i]])
        parent, edge = random.choice(connection_options)
        new_graph[parent].add(current_node)
        outgoing_edges[parent] -= 1
    #leftover edges
    for i in range(len(new_nodes)):
        current_node = new_nodes[i]
        outgoing_left = outgoing_edges[current_node]
        connection_options = new_nodes[i+1:]
        #print(num_to_name[current_node], outgoing_left)
        if outgoing_left <= len(connection_options):
            children = random.sample(connection_options, outgoing_left)
        else:
            children = {random.choice(connection_options) for _ in range(outgoing_left)}
        new_graph[current_node] = new_graph[current_node].union(children)
    return {str(x):set(map(str,y)) for x,y in new_graph.items()}


print(ev_4_dag)
print(genComparableGraph(ev_4_dag))

#+END_SRC

#+RESULTS:
[[file:{'ev_SS': [], '6': [], '4': [], 'App1': ['4', 'App3', 'ev_SS'], 'App2': ['6', 'ev_SS', 'App1'], '2': [], 'ev_8.ev_2': [], 'App3': ['ev_8.ev_2', '2', 'ev_SS']}]]
[[file:['App1', 'App2', '2', 'ev_0', 'O', 'ev_SS']]]
[[file:[3, 6, 0, 4, 5, 2, 7, 8, 1, 9]]]
[[file:[5, 1, 4]]]
[[file:['App2', 'App1', 'App3', '2', 'ev_8.ev_2', '4', '6', 'ev_SS']]]
[[file:[]]]
[[file:[1, 5, 3]]]
[[file:[(0, 3), (1, 2), (2, 1)]]]
[[file:[(0, 0), (1, 1), (2, 2), (3, 3)]]]
[[file:[0, 2, 3, 1]]]

*** Gen replica alternate


topological sort
find pair of edges
flip if still dag

#+BEGIN_SRC python :session :results output silent

  def genComparableGraphInOut(theorem_dag, num_iterations):
      dag = copy.deepcopy(theorem_dag)
      num_nodes = len(dag)
      top_sort = list(nx.topological_sort(nx.DiGraph(dag)))
      node_to_index = {v:i for i,v in enumerate(top_sort)}
      for _ in range(num_iterations):
          e1_end, e2_end = None, None
          while not e1_end:
              e1_start = random.choice(range(num_nodes))
              e1_end_options = list(map(lambda v: node_to_index[v], dag[top_sort[e1_start]]))
              if e1_end_options:
                  e1_end = random.choice(e1_end_options)
          while not e2_end:
              e2_start = random.choice(range(e1_end))
              e2_end_options = list(filter(lambda x: x > e1_start,
                                           map(lambda v: node_to_index[v], dag[top_sort[e2_start]])))
              if e2_end_options:
                  e2_end = random.choice(e2_end_options)
          #now switch
          dag[top_sort[e1_start]].remove(top_sort[e1_end])
          dag[top_sort[e1_start]].add(top_sort[e2_end])
          dag[top_sort[e2_start]].remove(top_sort[e2_end])
          dag[top_sort[e2_start]].add(top_sort[e1_end])
      assert(nx.is_directed_acyclic_graph(nx.DiGraph(dag)))
      return dag

#+END_SRC

*** Plot generated replica DAG's
**** ev_4

#+BEGIN_SRC python :session :results file
outfile = './Images/ev_4_gen_DAG.png'
ev_4_dag = toplistToDAG(utils.ev_4_tree,'ev_4')
gen_ev_4_dag = genComparableGraph(ev_4_dag, num_iterations=10)
plotGraphs(nx.DiGraph(ev_4_dag),
                     nx.DiGraph(gen_ev_4_dag), outfile, label=True, figsize=(6,6))
outfile
#+END_SRC

#+RESULTS:
[[file:./Images/ev_4_gen_DAG.png]]

**** ev_8

#+BEGIN_SRC python :session :results file
outfile = './Images/ev_8_gen_DAG.png'
ev_8_dag = toplistToDAG(utils.ev_8_tree,'ev_8')
gen_ev_8_dag = genComparableGraphInOut(ev_8_dag,num_iterations=10)
plotGraphs(nx.DiGraph(ev_8_dag),
                     nx.DiGraph(gen_ev_8_dag), outfile, label=True, figsize=(8,8))
'./Images/ev_8_gen_DAG.png'
#+END_SRC

#+RESULTS:
[[file:./Images/ev_8_gen_DAG.png]]

**** ev_4_alt

#+BEGIN_SRC python :session :results file
outfile = './Images/ev_4_alt_gen_DAG.png'
ev_4_alt_dag = toplistToDAG(utils.ev_4_alt_tree,'ev_4_alt')
gen_ev_4_alt_dag = genComparableGraph(ev_4_alt_dag)
plotGraphs(nx.DiGraph(ev_4_alt_dag),
                     nx.DiGraph(gen_ev_4_alt_dag), outfile, label=True, figsize=(8,8))

'./Images/ev_4_alt_gen_DAG.png'
#+END_SRC

#+RESULTS:
[[file:./Images/ev_4_alt_gen_DAG.png]]

**** sqrt2_not_rational

#+BEGIN_SRC python :session :results file
theorem_name = 'sqrt2_not_rational'
outfile = './Images/'+theorem_name+'_gen_DAG.png'
#tree = utils.theoremNameToLists(theorem_name)
#dag = toplistToDAG(utils.sqrt2_tree, 'sqrt2_not_rational')
#gen_dag = genComparableGraphInOut(dag, num_iterations=10) #P52 in values but not in keys
#plotGraphs(nx.DiGraph(dag),
#           nx.DiGraph(gen_dag), outfile, label=False, figsize=(8,8))
outfile
#+END_SRC

#+RESULTS:
[[file:./Images/sqrt2_not_rational_gen_DAG.png]]



*** Export multiple replica DAG's
**** Utils

#+BEGIN_SRC python :session :results output silent

def genComparableGraphsSlow(theorem_dag, num_graphs, test=False):
    #prep
    theorem_nodes = list(theorem_dag.keys())
    name_to_num = {name: num for num, name in enumerate(theorem_nodes)}
    num_to_name = {num: name for num, name in enumerate(theorem_nodes)}
    original_outgoing_edges = {n: len(theorem_dag[num_to_name[n]])
                                 for n in range(len(theorem_nodes))}
    #create random connections that match arities
    new_graphs = []
    for _ in range(num_graphs):
        top_sort = randomTopSort(theorem_dag)
        outgoing_edges = copy.deepcopy(original_outgoing_edges)
        if test:
            assert(checkTopOrder(top_sort, theorem_dag)) #errors in here
            assert(outgoing_edges[name_to_num[top_sort[-1]]] == 0)
        new_nodes = [name_to_num[name] for name in top_sort]
        new_graph = {n:set() for n in range(len(theorem_nodes))}
        #first pass
        for i in range(1,len(new_nodes)):
            current_node = new_nodes[i]
            connection_options = flatten([[(parent, edge) for edge in range(outgoing_edges[parent])]
                                            for parent in new_nodes[:i]])
            parent, edge = random.choice(connection_options)
            new_graph[parent].add(current_node)
            outgoing_edges[parent] -= 1
        #leftover edges
        for i in range(len(new_nodes)):
            current_node = new_nodes[i]
            outgoing_left = outgoing_edges[current_node]
            connection_options = new_nodes[i+1:]
            #print(num_to_name[current_node], outgoing_left)
            children = {random.choice(connection_options) for _ in range(outgoing_left)}
            new_graph[current_node] = new_graph[current_node].union(children)
        new_graphs.append(new_graph)
    return new_graphs


def genComparableGraphs(theorem_dag, num_graphs, test=False):
    #preprocessing
    theorem_nodes = list(theorem_dag.keys())
    name_to_num = {name: num for num, name in enumerate(theorem_nodes)}
    num_to_name = {num: name for num, name in enumerate(theorem_nodes)}
    original_outgoing_edges = {n: len(theorem_dag[num_to_name[n]])
                                 for n in range(len(theorem_nodes))}
    #create random connections that match arities
    new_graphs = []
    for _ in range(num_graphs):
        top_sort = randomTopSort(theorem_dag)
        outgoing_edges = copy.deepcopy(original_outgoing_edges)
        if test:
            assert(checkTopOrder(top_sort, theorem_dag)) #errors in here
            assert(outgoing_edges[name_to_num[top_sort[-1]]] == 0)
        new_nodes = [name_to_num[name] for name in top_sort]
        new_graph = {n:set() for n in range(len(theorem_nodes))}
        #first pass
        for i in range(1,len(new_nodes)):
            current_node = new_nodes[i]
            #connection_options = flatten([[(parent, edge) for edge in range(outgoing_edges[parent])]
            #                                for parent in new_nodes[:i]])
            parent = new_nodes[random.choice(range(i))]
            while outgoing_edges[parent] == 0:
                parent = new_nodes[random.choice(range(i))]
            new_graph[parent].add(current_node)
            outgoing_edges[parent] -= 1
        #leftover edges
        for i in range(len(new_nodes)):
            current_node = new_nodes[i]
            outgoing_left = outgoing_edges[current_node]
            connection_options = new_nodes[i+1:]
            #print(num_to_name[current_node], outgoing_left)
            children = {random.choice(connection_options) for _ in range(outgoing_left)}
            new_graph[current_node] = new_graph[current_node].union(children)
        new_graphs.append(new_graph)
    return new_graphs

#def genComparableGraphs2(theorem_dag, num_graphs):
#    return [genComparableGraph2(theorem_dag) for _ in range(num_graphs)]

def exportOrigAndReplicas(theorem_dag, theorem_name, num_replicas, depth=2, mod_libs=False, plot=False):
    outfolder = './ProofDAGs/'+theorem_name+'/'
    if not os.path.exists(outfolder):
        os.mkdir(outfolder)
    orig_out = outfolder+'d'+str(depth)+('_mod.txt' if mod_libs else '.txt')
    with open(orig_out,'w') as f:
        json.dump({k:list(v) for k,v in theorem_dag.items()}, f)
    if plot:
        plotGraph(nx.DiGraph(theorem_dag), './Images/'+theorem_name+'_orig_DAG.png')
    gen_dags = genComparableGraphs(theorem_dag, num_replicas)
    for i,g in enumerate(gen_dags):
        replica_out = outfolder+'gen_d'+str(depth)+('_mod_' if mod_libs else '_')+str(i)+'.txt'
        with open(replica_out, 'w') as f:
            json.dump({k:list(v) for k,v in g.items()}, f)
        if plot:
            plotGraph(nx.DiGraph(g), './Images/'+theorem_name+'_gen_DAG_'+str(i)+'.png')

def exportReplicas(theorem_name, depth, num_replicas, mod_libs=False):
    outfolder = './ProofDAGs/'+theorem_name+'/'
    theorem_dag = importOrigDAG(theorem_name, depth)
    gen_dags = genComparableGraphs(theorem_dag, num_replicas)
    for i,g in enumerate(gen_dags):
        gen_file = outfolder+'gen_d'+str(depth)+('_mod_' if mod_libs else '_')+str(i)+'.txt'
        with open(gen_file, 'w') as f:
            json.dump({k:list(v) for k,v in g.items()}, f)

def exportDAGs(theorem_name, max_depth, num_replicas, mod_libs=False, plot=False):
    for depth in range(1, max_depth+1):
        tree = utils.theoremNameToLists(theorem_name, depth, mod_libs=mod_libs)
        dag = toplistToDAG(tree, depth=depth)
        exportOrigAndReplicas(dag, theorem_name, num_replicas, depth=depth, mod_libs=mod_libs, plot=plot)

def exportLibDAG(library_name, max_depth, num_replicas, limit=None, mod_libs=False, plot=False):
    for depth in range(1, max_depth+1):
        dag = libNameToDAG(library_name, depth=depth, mod_libs=mod_libs, limit=limit)
        exportOrigAndReplicas(dag, library_name, num_replicas, depth=depth, mod_libs=mod_libs, plot=plot)

#+END_SRC

**** ev_4

#+BEGIN_SRC python :session :results output silent
theorem_name = 'ev_4'
exportDAGs(theorem_name, max_depth=3, num_replicas=5, mod_libs=False)
#+END_SRC

**** ev_8

#+BEGIN_SRC python :session :results output silent
theorem_name = 'ev_8'
exportDAGs(theorem_name, max_depth=3, num_replicas=5, mod_libs=False)
#+END_SRC

**** ev_8_alt

#+BEGIN_SRC python :session :results output silent
theorem_name = 'ev_8_alt'
exportDAGs(theorem_name, max_depth=5, num_replicas=5, mod_libs=False)
#+END_SRC

**** sqrt2_not_rational

#+BEGIN_SRC python :session :results output silent
theorem_name = 'sqrt2_not_rational'
exportDAGs(theorem_name, max_depth=3, num_replicas=5, mod_libs=False)
#+END_SRC

**** birthday_paradox

#+BEGIN_SRC python :session :results output silent
theorem_name = 'birthday_paradox'
exportDAGs(theorem_name, max_depth=4, num_replicas=5, mod_libs=False)
#+END_SRC

**** bertrand_ballot

#+BEGIN_SRC python :session :results output silent
theorem_name = 'bertrand_ballot'
exportDAGs(theorem_name, max_depth=2, num_replicas=5, mod_libs=False)
#+END_SRC

**** FTA

#+BEGIN_SRC python :session :results output silent
theorem_name = 'FTA'
exportDAGs(theorem_name, max_depth=4, num_replicas=5, mod_libs=False)
#+END_SRC

**** Pythagorean Theorem

#+BEGIN_SRC python :session :results output silent
theorem_name = 'pythagoras'
exportDAGs(theorem_name, max_depth=2, num_replicas=5, mod_libs=False)
#+END_SRC

**** Quadratic_reciprocity

#+BEGIN_SRC python :session :results output silent
theorem_name = 'Quadratic_reciprocity'
exportDAGs(theorem_name, max_depth=2, num_replicas=5, mod_libs=False)
#+END_SRC

**** Euler_exp_totient

#+BEGIN_SRC python :session :results output silent
theorem_name = 'Euler_exp_totient'
exportDAGs(theorem_name, max_depth=3, num_replicas=5, mod_libs=False)
#+END_SRC

**** FTC (Fundamental Theorem of Integral Calculus)

#+BEGIN_SRC python :session :results output silent
theorem_name = 'FTC1'
exportDAGs(theorem_name, max_depth=2, num_replicas=5, mod_libs=False)
#+END_SRC

**** Liouville's Theorem and the Construction of Trancendental Numbers

#+BEGIN_SRC python :session :results output silent
theorem_name = 'Liouville_theorem'
exportDAGs(theorem_name, max_depth=3, num_replicas=5, mod_libs=False)
#+END_SRC

**** The Non-Denumerability of the Continuum

#+BEGIN_SRC python :session :results output silent
theorem_name = 'reals_not_countable'
exportDAGs(theorem_name, max_depth=1, num_replicas=5, mod_libs=False)
#+END_SRC

**** Leibniz's Series for Pi

#+BEGIN_SRC python :session :results output silent
theorem_name = 'Alt_PI_eq'
exportDAGs(theorem_name, max_depth=1, num_replicas=5, mod_libs=False)
#+END_SRC

**** Pigeonhole

#+BEGIN_SRC python :session :results output silent
theorem_name = 'Pigeonhole'
exportDAGs(theorem_name, max_depth=1, num_replicas=5, mod_libs=False)
#+END_SRC

**** Taylor's Theorem

#+BEGIN_SRC python :session :results output silent
theorem_name = 'Taylor'
exportDAGs(theorem_name, max_depth=1, num_replicas=5, mod_libs=False)
#+END_SRC

**** Four Color Theorem

#+BEGIN_SRC python :session :results output silent
theorem_name = 'four_color'
exportDAGs(theorem_name, max_depth=4, num_replicas=5, mod_libs=False)
#+END_SRC

**** Arith Library

#+BEGIN_SRC python :session :results output silent
library_name = 'Arith'
exportLibDAG(library_name, max_depth=2, num_replicas=5, mod_libs=False)
#+END_SRC

**** GeoCoq Library

***** Boilerplate

#+BEGIN_SRC python :session :results output silent
  def getGeoCoqTheorems(depth=2, mod_libs=False, limit=None):
      if not os.path.exists('./ProofTrees/euclid_book_d'+str(depth)+'.txt'):
          subprocess.call(['./make_euclid_theorems.sh', str(depth)])
      with open('./ProofTrees/euclid_book_d'+str(depth)+'.txt','r') as f:
          theorem_names = list(map(lambda x:"euclid."+x.strip(), f.readlines()))
      if limit:
          theorem_names = theorem_names[:limit]
      theorems = {}
      return {theorem_name: utils.theoremNameToLists(theorem_name, depth=depth, mod_libs=mod_libs)
           for theorem_name in theorem_names}

  def getGeoCoqDAG(depth=2, mod_libs=False, limit=None):
      theorem_dict = getGeoCoqTheorems(depth=depth, mod_libs=mod_libs, limit=limit)
      theorem_tree = ['Top'] + list(map(lambda x:x[1], theorem_dict.values()))
      library_dag = toplistToDAG(theorem_tree)
      return library_dag

  def exportGeoCoqDAG(max_depth, num_replicas, limit=None, mod_libs=False, plot=False):
      for depth in range(1, max_depth+1):
          dag = getGeoCoqDAG(depth=depth, mod_libs=mod_libs, limit=limit)
          exportOrigAndReplicas(dag, 'euclid_book', num_replicas, depth=depth, mod_libs=mod_libs, plot=plot)

  def geoTreesToDAGs(depth):
      euclid_theorems = list(filter(lambda x: x[:7] == 'euclid.', os.listdir('./ProofTrees')))
      trees = map(lambda x: utils.theoremNameToLists(x, depth=depth), euclid_theorems)
      dags = map(toplistToDAG, trees)
      for theorem_name, dag in zip(euclid_theorems, dags):
          outfile = './ProofDAGs/'+theorem_name+'/d'+str(depth)+'.txt'
          if not os.path.exists('./ProofDAGs/'+theorem_name):
              os.mkdir('./ProofDAGs/'+theorem_name)
          with open(outfile,'w') as f:
              json.dump({k:list(v) for k,v in dag.items()}, f)

#+END_SRC

***** Export

#+BEGIN_SRC python :session :results output silent
exportGeoCoqDAG(max_depth=1, num_replicas=5, mod_libs=False)
#+END_SRC



** DAG analysis
*** Plotting and Import/Export

#+BEGIN_SRC python :session :results output silent

def plotLineGraph(vals, outfile, figsize=(6,4)):
    fig, axs = plt.subplots(1, 1, sharex = True, figsize=figsize)
    axs.plot(range(len(vals)), vals, 'r+')
    fig.tight_layout()
    plt.savefig(outfile)

def modifiedLog(x):
    return 0 if x == 0 else math.log(x)

def plotLineGraphLogLog(vals, outfile, figsize=(6,4)):
    fig, axs = plt.subplots(1, 1, sharex = True, figsize=figsize)
    axs.plot(list(map(modifiedLog, range(len(vals)))),
             list(map(modifiedLog, vals)), 'r+')
    fig.tight_layout()
    plt.savefig(outfile)


def plotLineGraphs(vals, outfile):
    figsize = (6,3*len(vals))
    fig, axs = plt.subplots(len(vals), 1, sharex = True, figsize=figsize)
    for i in range(len(vals)):
        ax = axs[i]
        ax.plot(range(len(vals[i])), vals[i], 'r+')
    fig.tight_layout()
    plt.savefig(outfile)

def importDAG(filename):
    with open(filename,'r') as f:
       return json.loads(f.readline())

def importOrigDAG(theorem_name, depth, mod_libs=False):
    filename = './ProofDAGs/'+theorem_name+'/d'+str(depth)+('_mod.txt' if mod_libs else '.txt')
    return importDAG(filename)

def stringifyValues(d):
    return {k:list(map(str, v)) for k,v in d.items()}

def importRandDAGs(theorem_name, depth, mod_libs=False):
    folder_name = './ProofDAGs/'+theorem_name
    search_string = 'gen_d'+str(depth)+('_mod_' if mod_libs else '_')
    filenames = map(lambda y: folder_name +'/'+y,
                    filter(lambda x: search_string in x,
                           os.listdir(folder_name)))
    return list(map(stringifyValues, map(importDAG, filenames)))

#+END_SRC

*** Degree Distributions
**** Definitions
#+BEGIN_SRC python :session :results output silent

def getDegreeDist(dag, in_or_out):
    node_degrees = getNodeIndegrees(dag) if in_or_out == 'in' else getNodeOutdegrees(dag)
    degrees_to_nodes = flipDictionary(node_degrees)
    return {k:len(v) for k,v in degrees_to_nodes.items()}

def getOutdegreeDist(dag):
    node_outdegrees = {k:len(v) for k,v in dag.items()}
    outdegrees_to_nodes = flipDictionary(node_outdegrees)
    return {k:len(v) for k,v in outdegrees_to_nodes.items()}


def sparseToDense(d):
    return [d[x] if x in d else 0 for x in range(max(d)+1)]

def getDegreeOrigFileName(theorem_name, depth, in_or_out, mod_libs=False):
    return './Images/'+theorem_name+'_d'+str(depth)+('_mod_' if mod_libs else '_')+in_or_out+'degree_dist.png'

def plotOrigDegreeDist(theorem_name, depth, in_or_out, mod_libs=False):
    dag = importOrigDAG(theorem_name, depth, mod_libs=mod_libs)
    sparse_degree_dist = getDegreeDist(dag, in_or_out)
    degree_dist = sparseToDense(sparse_degree_dist)
    plotLineGraphLogLog(degree_dist, getDegreeOrigFileName(theorem_name, depth, in_or_out, mod_libs=mod_libs))

def sumDicts(d1, d2):
    all_keys = set(d1.keys()).union(set(d2.keys()))
    out = dict()
    for k in all_keys:
        if (k in d1) and (k in d2):
            out[k] = d1[k] + d2[k]
        elif k in d1:
            out[k] = d1[k]
        else:
            out[k] = d2[k]
    return out

assert(sumDicts({'fs':1}, {'fdsa':1, 'fs':2}) == {'fdsa':1, 'fs':3})

def averageDicts(dicts):
    sum_dicts = functools.reduce(sumDicts, dicts, {})
    return {k:v/len(dicts) for k,v in sum_dicts.items()}

def getDegreeRandFileName(theorem_name, depth, in_or_out, mod_libs=False):
    return './Images/gen_'+theorem_name+'_d'+str(depth)+('_mod_' if mod_libs else '_')+in_or_out+'degree_dist.png'

def plotRandDegreeDist(theorem_name, depth, in_or_out, mod_libs=False):
    dags = importRandDAGs(theorem_name, depth)
    degree_dists = list(map(lambda x: getDegreeDist(x, in_or_out), dags))
    sparse_degree_dist_ave = averageDicts(degree_dists)
    plotLineGraphLogLog(sparseToDense(sparse_degree_dist_ave),
                        getDegreeRandFileName(theorem_name, depth, in_or_out, mod_libs=mod_libs))

#+END_SRC

**** Examples

#+BEGIN_SRC python :session :results file
theorem_name, depth, in_or_out, mod_libs = 'birthday_paradox', 3, 'in', True
plotOrigDegreeDist(theorem_name, depth, in_or_out, mod_libs=mod_libs)
getDegreeOrigFileName(theorem_name, depth, in_or_out, mod_libs=mod_libs)
#+END_SRC

#+RESULTS:
[[file:./Images/birthday_paradox_d3_mod_indegree_dist.png]]

#+BEGIN_SRC python :session :results file
theorem_name, depth, in_or_out, mod_libs = 'sqrt2_not_rational', 3, 'in', False
plotRandDegreeDist(theorem_name, depth, in_or_out, mod_libs=mod_libs)
getDegreeRandFileName(theorem_name, depth, in_or_out, mod_libs=mod_libs)
#+END_SRC

#+RESULTS:
[[file:./Images/gen_sqrt2_not_rational_d3_indegree_dist.png]]


*** Count number of undirected loops

#+BEGIN_SRC python :session :results output silent

def countNumSimplePaths(dag):
    undir_G = nx.Graph(dag)
    total = 0
    for x in dag:
        total += len(list(nx.all_simple_paths(undir_G, x,x)))
    return total

#+END_SRC

*** Pagerank
**** Utils
#+BEGIN_SRC python :session :results output silent

def getPageRank(dag):
    return nx.algorithms.link_analysis.pagerank(nx.Graph(dag))

def getAveragePageRank(dags):
    return averageDicts(list(map(getPageRank, dags)))

def getSortedRankings(rankings):
    return sorted(rankings.values(), key=lambda x: -x)

def pageRankOrigFileName(theorem_name, depth, mod_libs=False):
    return './Images/'+theorem_name+'_d'+str(depth)+('_mod_' if mod_libs else '_')+'page_rank.png'

def pageRankRandFileName(theorem_name, depth, mod_libs=False):
    return './Images/'+theorem_name+'_d'+str(depth)+('_mod_' if mod_libs else '_')+'gen_page_rank.png'

def plotOrigPageRank(theorem_name, depth, mod_libs=False):
    dag = importOrigDAG(theorem_name, depth, mod_libs=mod_libs)
    rank = getSortedRankings(getPageRank(dag))
    #print("Beta: ", estimateBeta(rank))
    plotLineGraphLogLog(rank, pageRankOrigFileName(theorem_name, depth, mod_libs=mod_libs))

def plotRandPageRank(theorem_name, depth, mod_libs=False):
    dags = importRandDAGs(theorem_name, depth, mod_libs=mod_libs)
    rank = getSortedRankings(getAveragePageRank(dags))
    #print("Beta: ", estimateBeta(rank))
    plotLineGraphLogLog(rank, pageRankRandFileName(theorem_name, depth, mod_libs=mod_libs))

def average(lst):
    return sum(lst)/len(lst)

def estimateBeta(rankings):
    exp_val_log = sum(list(map(lambda x: rankings[x]*math.log(x), rankings)))
    return fsolve(lambda beta: exp_val_log - digamma(beta) + digamma(len(rankings)*beta), 0.5)


#+END_SRC

**** Examples
***** sqrt2_not_rational
****** Original

#+BEGIN_SRC python :session :results file
theorem_name, depth, mod_libs = 'sqrt2_not_rational', 3, False
plotOrigPageRank(theorem_name, depth, mod_libs=mod_libs)
pageRankOrigFileName(theorem_name, depth, mod_libs=mod_libs)
#+END_SRC

#+RESULTS:
[[file:./Images/sqrt2_not_rational_d3_page_rank.png]]

****** Null model

#+BEGIN_SRC python :session :results file
theorem_name, depth, mod_libs = 'sqrt2_not_rational', 3, True
plotRandPageRank(theorem_name, depth, mod_libs=mod_libs)
pageRankRandFileName(theorem_name, depth, mod_libs=mod_libs)
#+END_SRC

#+RESULTS:
[[file:./Images/sqrt2_not_rational_d3_mod_gen_page_rank.png]]

*** Modularity

#+BEGIN_SRC python :session :results output silent

def getModularity(dag):
   graph = nx.Graph(dag)
   partition = community.best_partition(graph)
   return community.modularity(partition, graph)

def getModularitiesFileName(theorem_name, depth, mod_libs=False):
    return './Images/'+theorem_name+'_d'+str(depth)+('_mod_' if mod_libs else '_')+'modularities.png'

def plotOrigVRandModularity(theorem_name, depth, outfile, mod_libs=False):
    orig_modularity = getModularity(importOrigDAG(theorem_name, depth, mod_libs=mod_libs))
    #print("orig modularity: ", orig_modularity)
    rand_modularities = list(map(getModularity, importRandDAGs(theorem_name, depth, mod_libs=mod_libs)))
    plotLineGraph([orig_modularity]+rand_modularities, outfile)

#+END_SRC

***** sqrt2_not_rational

#+BEGIN_SRC python :session :results file
theorem_name, depth, mod_libs = 'sqrt2_not_rational', 2, False
outfile = getModularitiesFileName(theorem_name, depth, mod_libs=mod_libs)
plotOrigVRandModularity(theorem_name, depth, outfile, mod_libs=mod_libs)
outfile
#+END_SRC

#+RESULTS:
[[file:./Images/sqrt2_not_rational_d2_modularities.png]]

***** Elements

#+BEGIN_SRC python :session :results file
theorem_name, depth, mod_libs = 'sqrt2_not_rational', 2, False
outfile = getModularitiesFileName(theorem_name, depth, mod_libs=mod_libs)

tree = json.loads(open('/home/scottviteri/Downloads/elements.txt','r').read())
dag = {x[0]:set(x[1]) for x in tree}
rand_dags = genComparableGraphs(dag, 5)

orig_modularity = getModularity(dag)
#print("orig modularity: ", orig_modularity)
rand_modularities = list(map(getModularity, rand_dags))
plotLineGraph([orig_modularity]+rand_modularities, outfile)

outfile
#+END_SRC

#+RESULTS:
[[file:./Images/sqrt2_not_rational_d2_modularities.png]]



** DAG Generative Model

**** Create DAG

#+BEGIN_SRC python :session :results output silent

def getAncestors(node, graph):
    queue = [{node}]
    non_ancestors = set(graph.keys())
    while queue:
        child_layer = queue.pop()
        non_ancestors -= child_layer
        parent_layer = set()
        for n in non_ancestors:
            if graph[n].intersection(child_layer):
                parent_layer.add(n)
        if parent_layer:
            queue.append(parent_layer)
    non_ancestors.add(node)
    return graph.keys() - non_ancestors

assert(getAncestors('b',{'a':{'b','c'}, 'b':set(),'c':set()}) == {'a'})
assert(getAncestors('a',{'a':{'b','c'}, 'b':set(),'c':set()}) == set())
assert(getAncestors('d',{'a':{'b','c'}, 'b':{'d'},'c':{'d'},'d':set()}) == {'a','b','c'})
assert(getAncestors('d',{'a':{'b','c'}, 'b':{'d'},'c':{'d'},'d':set(),'e':set()}) == {'a','b','c'})

def createGraphSlow(m, p, q, num_iterations):
    d = {}
    for i in range(num_iterations):
        d['v'+str(i)] = set()
        if m > len(d.keys()):
            maybe_connect = d.keys()
        else:
            maybe_connect = random.sample(d.keys(), m)
        for x in maybe_connect:
            if random.random() < p:
                #d['v'+str(i)].add(x)
                d[x].add('v'+str(i))
                for ancestor in getAncestors(x, d):
                    if random.random() < q:
                        #d['v'+str(i)].add(ancestor)
                        d[ancestor].add('v'+str(i))
    return d

def createGraph(m, p, q, num_iterations):
    d = nx.DiGraph()
    for i in range(num_iterations):
        d.add_node('v'+str(i))
        if m >= d.number_of_nodes():
            maybe_connect = d.nodes()
        else:
            maybe_connect = random.sample(d.nodes(), m)
        for x in maybe_connect:
            if random.random() < p:
                d.add_edge(x, 'v'+str(i))
                for ancestor in nx.algorithms.dag.ancestors(d,x):
                    if random.random() < q:
                        d.add_edge(ancestor, 'v'+str(i))
    return {k:set(v) for k,v in nx.convert.to_dict_of_lists(d).items()}


#+END_SRC

#+BEGIN_SRC python :session :results file
graph = createGraph(3,.5,.33,50)
outfile = 'Images/genGraph.png'
plotGraph(nx.DiGraph(graph), outfile)
outfile
#+END_SRC

#+RESULTS:
[[file:Images/genGraph.png]]

#+BEGIN_SRC python :session :results output silent
def plotDegreeDist(graph, in_or_out, outfile):
   dist = getDegreeDist(graph, in_or_out)
   plotLineGraph(sparseToDense(dist), outfile)
#+END_SRC

#+BEGIN_SRC python :session :results file
outfile, in_or_out = 'genGraph_degree_dist.png', 'out'
graph = createGraph2(3,.6,.33,1000)
plotDegreeDist(graph, in_or_out, outfile)
outfile
#+END_SRC

#+RESULTS:
[[file:genGraph_degree_dist.png]]

** DAG analysis'

*** Basic DAG Analysis Utils

**** Utils

#+BEGIN_SRC python :session :results output silent

def testDAG(g):
    nx.write_adjlist(nx.DiGraph(g), './temp.txt')
    return nx.read_adjlist('./temp.txt', create_using=nx.DiGraph())

def importReplicas(theorem_name):
    in_folder = './ProofDAGs/'+theorem_name+'/'
    orig = []
    replicas = []
    for f in os.listdir(in_folder):
        dag = nx.read_adjlist(in_folder+f,create_using=nx.DiGraph())
        if 'gen' in f:
            replicas.append(dag)
        else:
            orig.append(dag)
    assert(len(orig) == 1)
    return orig[0], replicas

def nxToDict(graph):
    return {k:set(v) for k,v in nx.to_dict_of_lists(graph).items()}

def importReplicasToDict(theorem_name):
    in_folder = './ProofDAGs/'+theorem_name+'/'
    orig = []
    replicas = []
    for f in os.listdir(in_folder):
        dag = nxToDict(nx.read_adjlist(in_folder+f,create_using=nx.DiGraph()))
        if 'gen' in f:
            replicas.append(dag)
        else:
            orig.append(dag)
    assert(len(orig) == 1)
    return orig[0], replicas


def average(lst):
    return sum(lst) / len(lst)

def dUnion(d1, d2):
    all_keys = set(d1.keys()).union(set(d2.keys()))
    out = dict()
    for k in all_keys:
        if k in d1:
            out[k] = d1[k]
        else:
            out[k] = d2[k]
    return out

def findStrictMotifMatches(motif, dag):
    downgraph_nodes = map(lambda k: (k, nx.algorithms.descendants(dag, k)), dag.nodes_iter())
    downgraphs = map(lambda n: (n[0], nx.DiGraph(dUnion({n[0]:dag[n[0]]},
                                                        {x:dag[x] for x in n[1]}))),
                     downgraph_nodes)
    return set(map(lambda p: p[0],
                   filter(lambda x: nx.is_isomorphic(motif, x[1]),
                          downgraphs)))

def createHist(lst):
    return list(map(lambda x: lst.count(x), range(max(lst)+1)))

def createDAGHist(dag):
    return createHist(list(map(len, dag.adjacency_list())))

def powerset(iterable):
    "powerset([1,2,3]) --> () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)"
    s = list(iterable)
    return itertools.chain.from_iterable(itertools.combinations(s, r) for r in range(len(s)+1))

def findAllCombosOfNodesUnder(node, dag, size):
    out_node_lists = [[node]]
    count = 0
    while any(map(lambda x: len(x) != size, out_node_lists)):
        node_list = out_node_lists.pop(0)
        print(node_list)
        for child_combo in powerset(dag[node_list[-1]]):
            if len(node_list) < size:
                out_node_lists.append(node_list+list(child_combo))
            elif len(node_list) == size:
                out_node_lists.append(node_list)
        count += 1
        if count > 5: break
    return out_node_lists

#+END_SRC

**** Partitioning Utils

#+BEGIN_SRC python :session :results output silent

def plotPartitions(G, partition, outfile):
    plt.figure()
    size = float(len(set(partition.values())))
    pos = nx.spring_layout(G)
    count = 0.
    for com in set(partition.values()) :
        list_nodes = [nodes for nodes in partition.keys()
                                    if partition[nodes] == com]
        nx.draw_networkx_nodes(G, pos, list_nodes, node_size = 20,
                                    node_color = str(count / size))
        count = count + 1.
    nx.draw_networkx_edges(G, pos, alpha=0.5)
    plt.savefig(outfile)

def plotPartitionComparison(graphs, partitions, outfile, figsize=(6,4)):
    fig, axs = plt.subplots(1, 1, sharex = True, figsize=figsize)
    modularities = list(map(lambda G_part: community.modularity(G_part[1], G_part[0]),
                            zip(graphs, partitions)))
    axs.plot(range(len(modularities)), modularities, 'r+')
    axs.set_title('Modularity v Replica Count')
    axs.set_xlabel('Replica Count')
    axs.set_ylabel('Modularity')
    fig.tight_layout()
    plt.savefig(outfile)

def theoremNameToPartitionOutfile(theorem_name):
    return './Images/'+theorem_name+'_partitions.png'

def plotPartitionsFromTheoremName(theorem_name):
    outfile = theoremNameToPartitionOutfile(theorem_name)
    if not os.path.exists(outfile):
        orig, replicas = importReplicas(theorem_name)
        testDAG(orig)
        G = nx.Graph(orig)
        partition = community.best_partition(G)
        plotPartitions(nx.Graph(orig), partition, outfile)

def theoremNameToModularitiesOutfile(theorem_name):
    return './Images/'+theorem_name+'_modularities.png'

def plotModularitiesFromTheoremName(theorem_name):
    outfile = theoremNameToModularitiesOutfile(theorem_name)
    if not os.path.exists(outfile):
        orig, replicas = importReplicas(theorem_name)
        graphs = list(map(nx.Graph, [orig] + replicas))
        testDAG(graphs[0])
        partitions = list(map(community.best_partition, graphs))
        plotPartitionComparison(graphs, partitions, outfile)

#+END_SRC

**** ev_8
***** Partition

#+BEGIN_SRC python :session :results file
theorem_name = 'ev_8'
plotPartitionsFromTheoremName(theorem_name)
theoremNameToPartitionOutfile(theorem_name)
#+END_SRC

#+RESULTS:
[[file:./Images/ev_8_partitions.png]]

***** Partition Replicas

#+BEGIN_SRC python :session :results file
theorem_name = 'ev_8'
plotModularitiesFromTheoremName(theorem_name)
theoremNameToModularitiesOutfile(theorem_name)
#+END_SRC

#+RESULTS:
[[file:./Images/ev_8_modularities.png]]

**** ev_8_alt
***** Partition

#+BEGIN_SRC python :session :results file
theorem_name = 'ev_8_alt'
plotPartitionsFromTheoremName(theorem_name)
theoremNameToPartitionOutfile(theorem_name)
#+END_SRC

#+RESULTS:
[[file:./Images/ev_8_alt_partitions.png]]

***** Partition Replicas

#+BEGIN_SRC python :session :results file
theorem_name = 'ev_8_alt'
plotModularitiesFromTheoremName(theorem_name)
theoremNameToModularitiesOutfile(theorem_name)
#+END_SRC

#+RESULTS:
[[file:./Images/ev_8_alt_modularities.png]]


#+END_SRC

**** sqrt2_not_rational
***** Partition

#+BEGIN_SRC python :session :results file
theorem_name = 'sqrt2_not_rational'
plotPartitionsFromTheoremName(theorem_name)
theoremNameToPartitionOutfile(theorem_name)
#+END_SRC

#+RESULTS:
[[file:./Images/sqrt2_not_rational_partitions.png]]

***** Partition Replicas

#+BEGIN_SRC python :session :results file
theorem_name = 'sqrt2_not_rational'
plotModularitiesFromTheoremName(theorem_name)
theoremNameToModularitiesOutfile(theorem_name)
#+END_SRC

#+RESULTS:
[[file:./Images/sqrt2_not_rational_modularities.png]]


#+END_SRC

*** DAG Motif Finding

#+BEGIN_SRC python :session :results output silent

def countFeedForward(dag):
    count = 0
    for n in dag:
        children = dag[n]
        for ch in children:
            grandchildren = dag[ch]
            if any(children & grandchildren):
                #print(n)
                count += 1
    return count

assert(countFeedForward(ev_8_dag) == 2)

def getAllFeedForwardMatches(dag):
    matches = []
    for n in dag:
        children = dag[n]
        for child in children:
            grandchildren = dag[child]
            for grandchild in grandchildren:
                if grandchild in children:
                    matches.append({n,child,grandchild})
    return matches

assert(getAllFeedForwardMatches(ev_8_dag)
       == [{'App1', 'App3', 'ev_SS'}, {'App2', 'App1', 'ev_SS'}])

def hasCrossRefs(group_of_matches, dag):
    has_cross_refs = False
    for i in range(len(group_of_matches)):
        match, rest = group_of_matches[i], group_of_matches[:i] + group_of_matches[i+1:]
        match_children = set()
        for x in match:
            match_children = match_children | dag[x]
        rest_nodes = set()
        for y in rest:
            rest_nodes = rest_nodes | y
        if any(match_children & rest_nodes):
            return True
    return has_cross_refs

assert(hasCrossRefs([{'App2','App1','ev_SS'},{'App3'}], ev_8_dag))
assert(not hasCrossRefs([{'App2','App1','ev_SS'},{'2'}], ev_8_dag))

def getLargestNonIntersectingGroup(matches, dag):
    largest_size = 0
    largest_group_of_matches = None
    for group_of_matches in powerset(matches):
        if group_of_matches:
            if len(group_of_matches) <= 1:
                is_overlapping = False
            else:
                is_overlapping = any(group_of_matches[0].intersection(*group_of_matches[1:]))
            if (not is_overlapping and not hasCrossRefs(group_of_matches, dag)
                                   and len(group_of_matches) > largest_size):
                largest_group_of_matches = group_of_matches
                largest_size = len(group_of_matches)
    return list(largest_group_of_matches) if largest_group_of_matches else []


assert(
    getLargestNonIntersectingGroup(
        [{'App1', 'App3', 'ev_SS'}, {'App2', 'App1', 'ev_SS'}], ev_8_dag) ==
    [{'App3', 'App1', 'ev_SS'}])

def removeGroupOfMatches(group_of_matches, dag):
    previous_motif_nodes = list(filter(lambda x: x[:6] == 'motif_', dag))
    if previous_motif_nodes:
        max_previous_motif_num = max(map(lambda y: int(y[6:]), previous_motif_nodes))
    else:
        max_previous_motif_num = 0
    new_motif_name = 'motif_' + str(max_previous_motif_num)
    new_dag = dag.copy()
    for match in group_of_matches:
        new_motif_name = new_motif_name[:6] + str(int(new_motif_name[6:])+1)
        new_dag[new_motif_name] = set()
        for node in dag:
            if any(dag[node] & match):
                new_dag[node] = (dag[node] - match) | {new_motif_name}
            if node in match:
                new_dag[new_motif_name] = new_dag[new_motif_name] | (dag[node] - match)
                del new_dag[node]
    return new_dag

def removeMatch(match, dag):
    previous_motif_nodes = list(filter(lambda x: x[:6] == 'motif_', dag))
    if previous_motif_nodes:
        max_previous_motif_num = max(map(lambda y: int(y[6:]), previous_motif_nodes))
    else:
        max_previous_motif_num = 0
    new_motif_name = 'motif_' + str(max_previous_motif_num)
    new_dag = dag.copy()
    new_motif_name = new_motif_name[:6] + str(int(new_motif_name[6:])+1)
    new_dag[new_motif_name] = set()
    for node in dag:
        if any(dag[node] & match):
            new_dag[node] = (dag[node] - match) | {new_motif_name}
        if node in match:
            new_dag[new_motif_name] = new_dag[new_motif_name] | (dag[node] - match)
            del new_dag[node]
    return new_dag

assert(
    removeGroupOfMatches([{'App3', 'App1', 'ev_SS'}], ev_8_dag) ==
    {'6': set(), '4': set(), 'App2': {'6', 'motif_1'}, '2': set(),
     'ev_8.ev_2': set(), 'motif_1': {'ev_8.ev_2', '2', '4'}})

def compressDAG(dag, repeat=1):
    new_dag = dag.copy()
    for _ in range(repeat):
        matches = getAllFeedForwardMatches(new_dag)
        #print("matches", matches)
        if matches:
            match = list(matches)[0]
            new_dag = removeMatch(match, new_dag)
        #group_of_matches = getLargestNonIntersectingGroup(matches, new_dag)
        #print("g of matches", group_of_matches)
        #if group_of_matches:
        #    new_dag = removeGroupOfMatches(group_of_matches, new_dag)
    return new_dag

def getCompressedDAGSizes(dag,repeat=1, theorem_name=None):
    new_dag = dag.copy()
    sizes = [len(new_dag)]
    for i in range(repeat):
        matches = getAllFeedForwardMatches(new_dag)
        if matches:
            match = list(matches)[0]
            new_dag = removeMatch(match, new_dag)
        sizes.append(len(new_dag))
        if theorem_name:
            plotGraph(nx.DiGraph(new_dag),
                                './Images/'+theorem_name+'_dag_compressed_'+str(i+1),
                                label=True)
    return sizes


def getCompressedDAGs(dag, repeat=1):
    new_dag = dag.copy()
    out_dags = [dag.copy()]
    for i in range(repeat):
        matches = getAllFeedForwardMatches(new_dag)
        print('hi',matches)
        if matches:
            match = list(matches)[0]
            new_dag = removeMatch(match, new_dag)
        out_dags.append(new_dag.copy())
    return out_dags

def getNumMotifs(dag, repeat=1, check_dag=False, theorem_name=None):
      new_dag = dag.copy()
      num_motifs = []
      print('0', nx.is_directed_acyclic_graph(nx.DiGraph(dag)))
      for i in range(repeat):
          matches = getAllFeedForwardMatches(new_dag)
          num_motifs.append(len(matches))
          if matches:
              match = list(matches)[0]
              new_dag = removeMatch(match, new_dag)
          if check_dag:
              print(str(i+1), nx.is_directed_acyclic_graph(nx.DiGraph(new_dag)))
          if theorem_name:
              plotGraph(nx.DiGraph(new_dag),
                                './Images/'+theorem_name+'_dag_compressed_'+str(i+1),
                                label=True)
      return num_motifs

#+END_SRC

*** Plot DAG motif finding and removal
**** ev_8

#+BEGIN_SRC python :session :results file
outfile = 'Images/ev_8_dag_compressed.png'
new_dag = compressDAG(ev_8_dag)
plotGraph(nx.DiGraph(new_dag), outfile, label=True)
outfile
#+END_SRC

#+RESULTS:
[[file:Images/ev_8_dag_compressed.png]]

#+BEGIN_SRC python :session :results file
outfile = 'Images/ev_8_mod_dag_compressed.png'
ev_8_dag_mod = ev_8_dag.copy()
ev_8_dag_mod['2'] = {'ev_8.ev_2'}
new_dag = compressDAG(ev_8_dag_mod, repeat=2)
plotGraph(nx.DiGraph(new_dag), outfile, label=True)
outfile
#+END_SRC

#+RESULTS:
[[file:Images/ev_8_mod_dag_compressed.png]]

**** ev_8_alt

#+BEGIN_SRC python :session :results file
outfile = 'Images/ev_8_alt_dag_compressed.png'
new_dag = compressDAG(toplistToDAG(utils.ev_8_alt_tree))
plotGraph(nx.DiGraph(new_dag), outfile, label=True)
outfile
#+END_SRC

#+RESULTS:
[[file:Images/ev_8_alt_dag_compressed.png]]

#+BEGIN_SRC python :session :results file
outfile = 'Images/ev_8_alt_dag_compressed_2.png'
new_dag = compressDAG(toplistToDAG(utils.ev_8_alt_tree),repeat=2)
plotGraph(nx.DiGraph(new_dag), outfile, label=True)
outfile
#+END_SRC

#+RESULTS:
[[file:Images/ev_8_alt_dag_compressed_2.png]]

*** Plot size v num compressions
**** ev_8
***** Original

#+BEGIN_SRC python :session :results file
outfile = 'Images/ev_8_dag_compression_comparison.png'
sizes = getCompressedDAGSizes(ev_8_dag, repeat=3, theorem_name='ev_8')
plotLineGraph(sizes, outfile)
outfile
#+END_SRC

#+RESULTS:
[[file:Images/ev_8_dag_compression_comparison.png]]

**** ev_8_alt
***** Original

#+BEGIN_SRC python :session :results file
outfile = 'Images/ev_8_alt_dag_compression_comparison.png'
dag = toplistToDAG(utils.ev_8_alt_tree)
sizes = getCompressedDAGSizes(dag, repeat=5, theorem_name='ev_8_alt')
plotLineGraph(sizes, outfile)
outfile
#+END_SRC

#+RESULTS:
[[file:Images/ev_8_alt_dag_compression_comparison.png]]

***** Replica

#+BEGIN_SRC python :session :results file
outfile = 'Images/ev_8_alt_gen_dag_compression_comparison.png'
orig, replicas = importReplicasToDict('ev_8_alt')
sizes = [getCompressedDAGSizes(replica, repeat=5, theorem_name='ev_8_alt')
           for replica in [orig]+replicas[:3]]
print(sizes)
plotLineGraphs(sizes, outfile)
outfile
#+END_SRC

#+RESULTS:
[[file:Images/ev_8_alt_gen_dag_compression_comparison.png]]

**** factorial

Notice that there are no cycles here despite the recursion

#+BEGIN_SRC python :session :results file
outfile = 'Images/factorial_dag.png'
fact_string = "(Top (Definition Top.fact (Fix (Functions (App fact 0 (Prod n nat nat) (Lambda n nat (Case 0 (Lambda n nat nat) (CaseMatch n) (CaseBranches (App S O) (Lambda n' nat (App Coq.Init.Nat.mul n (App fact n')))))))) 0)))"
fact_tree = utils.parenStringToLists(fact_string)
fact_dag = toplistToDAG(fact_tree)
plotGraph(nx.DiGraph(fact_dag), outfile, label=True)
outfile
#+END_SRC

#+RESULTS:
[[file:Images/factorial_dag.png]]

I don't believe I can create a cycle on the first pass, but unsure.
Try compression until cycle creation.

#+BEGIN_SRC python :session :results file
outfile = 'Images/factorial_repeat_motif.png'
dags = getCompressedDAGs(fact_dag, repeat=2)
plotGraphList([nx.DiGraph(x) for x in dags], outfile, label=True)
outfile
#+END_SRC

#+RESULTS:
[[file:Images/factorial_repeat_motif.png]]

#+BEGIN_SRC python :session :results file
outfile = 'Images/factorial_num_motifs.png'
sizes = getNumMotifs(fact_dag, repeat=4)
plotLineGraph(sizes, outfile)
outfile
#+END_SRC

#+RESULTS:
[[file:Images/factorial_num_motifs.png]]

Much higher average stopping point.

#+BEGIN_SRC python :session :results file
outfile = 'Images/factorial_gen_num_motifs.png'
sizes = getNumMotifs(genComparableGraph(fact_dag), repeat=8)
plotLineGraph(sizes, outfile)
outfile
#+END_SRC

#+RESULTS:
[[file:Images/factorial_gen_num_motifs.png]]

**** forward

#+BEGIN_SRC python :session :results file
outfile = 'Images/forward_dag.png'
forward_string = "(Top (Definition Top.forward (Lambda f (Prod Anonymous (App prod (Axiom Top.A) (Axiom Top.B)) (Axiom Top.C)) (Lambda a (Axiom Top.A) (Lambda b (Axiom Top.B) (Cast (Cast (App eq_refl (Axiom Top.C) (App f (App pair (Axiom Top.A) (Axiom Top.B) a b))) REVERTcast (App eq (Axiom Top.C) (App f (App pair (Axiom Top.A) (Axiom Top.B) (App Coq.Init.Datatypes.fst (Axiom Top.A) (Axiom Top.B) (App pair (Axiom Top.A) (Axiom Top.B) a b)) (App Coq.Init.Datatypes.snd (Axiom Top.A) (Axiom Top.B) (App pair (Axiom Top.A) (Axiom Top.B) a b)))) (App f (App pair (Axiom Top.A) (Axiom Top.B) a b)))) REVERTcast (App eq (Axiom Top.C) (App Top.uncurry (App Top.curry f) (App pair (Axiom Top.A) (Axiom Top.B) a b)) (App f (App pair (Axiom Top.A) (Axiom Top.B) a b)))))))))"
forward_tree = utils.parenStringToLists(forward_string)
forward_dag = toplistToDAG(forward_tree)
plotGraph(nx.DiGraph(forward_dag), outfile, label=True)
outfile
#+END_SRC

#+RESULTS:
[[file:Images/forward_dag.png]]

#+BEGIN_SRC python :session :results file
outfile = 'Images/forward_num_motifs.png'
sizes = getNumMotifs(forward_dag, repeat=15)
plotLineGraph(sizes, outfile)
outfile
#+END_SRC

#+RESULTS:
[[file:Images/forward_num_motifs.png]]


Similar average stopping point for random

#+BEGIN_SRC python :session :results file
outfile = 'Images/forward_gen_num_motifs.png'
sizes = getNumMotifs(genComparableGraph(forward_dag), repeat=15)
plotLineGraph(sizes, outfile)
outfile
#+END_SRC

#+RESULTS:
[[file:Images/forward_gen_num_motifs.png]]



#+BEGIN_SRC python :session :results file
outfile = 'Images/forward_repeat_motif.png'
dags = getCompressedDAGs(forward_dag, repeat=3)
plotGraphList([nx.DiGraph(x) for x in dags], outfile, label=True)
outfile
#+END_SRC

#+RESULTS:
[[file:Images/forward_repeat_motif.png]]

**** currying

***** Plot DAG

#+BEGIN_SRC python :session :results file
outfile = 'Images/curry_dag.png'
curry_string = "(Top (Definition Top.curry (Lambda f (Prod Anonymous (App prod (Axiom Top.A) (Axiom Top.B)) (Axiom Top.C)) (Lambda a (Axiom Top.A) (Lambda b (Axiom Top.B) (App f (App pair (Axiom Top.A) (Axiom Top.B) a b)))))))"
curry_tree = utils.parenStringToLists(curry_string)
curry_dag = toplistToDAG(curry_tree)
plotGraph(nx.DiGraph(curry_dag), outfile, label=True)
outfile
#+END_SRC

#+RESULTS:
[[file:Images/curry_dag.png]]

***** Plot num motifs

#+BEGIN_SRC python :session :results file
outfile = 'Images/curry_num_motifs.png'
sizes = getNumMotifs(curry_dag, repeat=5)
plotLineGraph(sizes, outfile)
outfile
#+END_SRC

#+RESULTS:
[[file:Images/curry_num_motifs.png]]

***** Plot num motifs of replica

#+BEGIN_SRC python :session :results file
outfile = 'Images/curry_gen_num_motifs.png'
sizes = getNumMotifs(genComparableGraph(curry_dag), repeat=5)
plotLineGraph(sizes, outfile)
outfile
#+END_SRC

#+RESULTS:
[[file:Images/curry_gen_num_motifs.png]]

*** Test hypo that more cycles in theorem version
**** dec inc

There are more in the theorem case, but hard to say if that is just because of the size.

#+BEGIN_SRC python :session :results file
outfile = 'Images/dec_inc_dag.png'
dec_inc_string = "(Top (Definition Top.dec_inc (Lambda nat (App Top.dec (App S gen_var_2)))))"
dec_inc_tree = utils.parenStringToLists(dec_inc_string)
dec_inc_dag = toplistToDAG(dec_inc_tree)
print(dec_inc_dag)
plotGraph(nx.DiGraph(dec_inc_dag), outfile, label=True)
outfile
#+END_SRC

#+RESULTS:
[[file:Images/dec_inc_dag.png]]

#+BEGIN_SRC python :session :results file
outfile = 'Images/dec_inc_num_motifs.png'
sizes = getNumMotifs(dec_inc_dag, repeat=10, theorem_name='dec_inc')
plotLineGraph(sizes, outfile)
outfile
#+END_SRC

#+RESULTS:
[[file:Images/dec_inc_num_motifs.png]]

**** dec inc prop

#+BEGIN_SRC python :session :results file
outfile = 'Images/dec_inc_prop_dag.png'
dec_inc_prop_string = "(Top (Definition Top.dec_inc_prop (Lambda nat (App eq_refl nat gen_var_1))))"
dec_inc_prop_tree = utils.parenStringToLists(dec_inc_prop_string)
dec_inc_prop_dag = toplistToDAG(dec_inc_prop_tree)
print(dec_inc_prop_dag)
plotGraph(nx.DiGraph(dec_inc_prop_dag), outfile, label=True)
outfile
#+END_SRC

#+RESULTS:
[[file:Images/dec_inc_prop_dag.png]]

#+BEGIN_SRC python :session :results file
outfile = 'Images/dec_inc_prop_num_motifs.png'
sizes = getNumMotifs(dec_inc_prop_dag, repeat=12)
plotLineGraph(sizes, outfile)
outfile
#+END_SRC

#+RESULTS:
[[file:Images/dec_inc_prop_num_motifs.png]]

DeBruijin is not quite what we are looking for -- is replacing the names inside of the body,
 but we want global names that can be pointed to
This global unique thing is different from alpha renaming
Also a sort of preemptive alpha renaming and only of closed terms

Keep a dictionary during parse, which is passed around with replacement names
Do not pass around, because variable names will incremement in levels -- can get several diff at same level with same name
Modify global dictionary

Should I keep a dictionary of names of strings?
If names then I will be able to plug and play in curry use of names

build_lambda
build_prod
build_let_in
build_fix_fun
build_inductive_name

*** Check num direct loops
**** Count cycles

#+BEGIN_SRC python :session :results output silent

def countCycles(dag):
    count = 0
    for n in dag:
        children = dag[n]
        for ch in children:
            grandchildren = dag[ch]
            if n in grandchildren:
                #print(n)
                count += 1
    return count

def getAllCycles(dag):
    matches = []
    for n in dag:
        children = dag[n]
        for child in children:
            grandchildren = dag[child]
            if n in grandchildren:
                matches.append({n,child})
    return matches


def getNumCycles(dag, repeat=1, check_dag=True, theorem_name=None):
      new_dag = dag.copy()
      num_motifs = []
      num_cycles = []
      print('0', nx.is_directed_acyclic_graph(nx.DiGraph(dag)))
      for i in range(repeat):
          matches = getAllFeedForwardMatches(new_dag)
          num_motifs.append(len(matches))
          num_cycles.append(countCycles(new_dag)/2)
          if matches:
              match = list(matches)[0]
              new_dag = removeMatch(match, new_dag)
          if check_dag:
              print(str(i+1), nx.is_directed_acyclic_graph(nx.DiGraph(new_dag)))
          if theorem_name:
              plotGraph(nx.DiGraph(new_dag),
                                './Images/'+theorem_name+'_dag_compressed_'+str(i+1),
                                label=True)
      return num_motifs, num_cycles

#+END_SRC

#+BEGIN_SRC python :session :results file
outfile = 'Images/dec_inc_num_cycles.png'
num_motifs, num_cycles = getNumCycles(dec_inc_dag, repeat=10)
plotLineGraphs([num_motifs, num_cycles], outfile)
outfile
#+END_SRC

#+RESULTS:
[[file:Images/dec_inc_num_cycles.png]]

**** sqrt2_not_rational

#+BEGIN_SRC python :session :results file
theorem_name = 'sqrt2_not_rational'
outfile = 'Images/'+theorem_name+'_num_cycles.png'
sqrt2_dag = toplistToDAG(utils.sqrt2_tree, 'sqrt2_not_rational')
motifs_and_cycles = getNumCycles(sqrt2_dag, check_dag = False, repeat=400)
plotLineGraphs(motifs_and_cycles, outfile)
outfile
#+END_SRC

#+RESULTS:
[[file:Images/sqrt2_not_rational_num_cycles.png]]
[[file:Images/sqrt2_not_rational_gen_num_cycles.png]]

**** sqrt2_not_rational_d3

#+BEGIN_SRC python :session :results file
theorem_name = 'sqrt2_not_rational_d3'
outfile = 'Images/'+theorem_name+'_num_cycles.png'
#sqrt2_d3_dag = toplistToDAG(sqrt2_d3_tree)
#motifs_and_cycles = getNumCycles(sqrt2_d3_dag, check_dag = False, repeat=1500)
#plotLineGraphs(motifs_and_cycles, outfile)
outfile
#+END_SRC

#+RESULTS:
[[file:Images/sqrt2_not_rational_d3_num_cycles.png]]

**** sqrt2_not_rational_d4

#+BEGIN_SRC python :session :results file
theorem_name = 'sqrt2_not_rational_d4'
outfile = 'Images/'+theorem_name'_num_cycles.png'
#sqrt2_d4_tree = utils.theoremNameToLists('sqrt2_not_rational',depth=4)
#sqrt2_d4_dag = toplistToDAG(sqrt2_d4_tree)
#motifs_and_cycles = getNumCycles(sqrt2_d4_dag, check_dag = False, repeat=2000)
#plotLineGraphs(motifs_and_cycles, outfile)
outfile
#+END_SRC

#+RESULTS:
[[file:Images/sqrt2_not_rational_d3_num_cycles.png]]



**** nat equality

#+BEGIN_SRC python :session :results file
outfile = 'Images/eq_dag.png'
eq_string = "(Top (Definition Top.eq_nat (Lambda nat (App Coq.Init.Datatypes.nat_ind (Lambda nat (App eq nat gen_var_3 gen_var_3)) (App eq_refl nat O) (Lambda nat (Lambda (App eq nat gen_var_4 gen_var_4) (App eq_refl nat (App S gen_var_4)))) gen_var_4))))"
eq_tree = utils.parenStringToLists(eq_string)
eq_dag = toplistToDAG(eq_tree)
plotGraph(nx.DiGraph(eq_dag), outfile, label=True)
outfile
#+END_SRC

#+RESULTS:
[[file:Images/eq_dag.png]]



#+BEGIN_SRC python :session :results file
outfile = 'Images/eq_num_cycles.png'
sizes = getNumCycles(eq_dag, theorem_name='eq', repeat=15)
plotLineGraphs(sizes, outfile)
outfile
#+END_SRC

#+RESULTS:
[[file:Images/eq_num_cycles.png]]

** Find compressions in propositional logic
