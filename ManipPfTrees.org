#+TITLE: Manipulate Proof Trees
#+OPTIONS: tex:t
#+STARTUP: latexpreview
#+LATEX_HEADER: \usepackage{qtree,tiks}


* Manip Proof Trees

** Imports

#+BEGIN_SRC python :session :results output silent

import utils
import math
import copy
import itertools
import pickle
import ast
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D  # noqa: F401 unused import
from matplotlib import cm
from matplotlib.ticker import LinearLocator, FormatStrFormatter
import numpy as np
import json
import functools
import pdb
import cProfile
import subprocess
import networkx as nx
import os
import random
import re
import community
from scipy.special import digamma
from scipy.optimize import fsolve
import powerlaw
import cylouvain

#+END_SRC

** Create theorem dags from unsubbed representations

*** Convert individual theorem tree to graph

#+BEGIN_SRC python :session :results output silent

cic_constructors = ['App', 'Definition', 'Axiom', 'Lambda',
                    'Cast', 'LetIn','Fix','CoFix',
                    'CaseMatch', 'CaseBranches','Sort',
                    'Prod','Inductive','Case','CoInductive',
                    'Record','VMCast','DEFAULTcast','REVERTcast',
                    'NATIVEcast','Var','Meta','Evar','Rel','Level',
                    'Max','Universe','UnivInstance','Sort','Prop','Type',
                    'Functions','Proj','Name','Anonymous']

def constructorMatch(test, constructor):
    return constructor == test[:len(constructor)]

assert(constructorMatch('App1','App'))
assert(not constructorMatch('App','App1'))

cic_regex = re.compile("^"+"|".join(cic_constructors))
def isConstructor(test):
    return bool(cic_regex.match(test))

assert(isConstructor('App1'))
assert(isConstructor('Lambda2'))
assert(isConstructor('Cast'))

def isShallowSubgraph(dag1, dag2):
    constructor, children = next(iter(dag1.items()))
    for k2 in dag2:
        if constructorMatch(k2, constructor) and children == dag2[k2]:
            return k2
    return False

assert(isShallowSubgraph({'App': {'1','2'}}, {'App1':{'1','2'}}) == 'App1')
assert(not isShallowSubgraph({'App':{'1','2'}}, {'App1':{'1','3'}}))

#+END_SRC


#+BEGIN_SRC python :session :results output

def listToDAGHelper(tree, out_dag, cic_count):
    if not isinstance(tree, list):
        out_dag[tree] = set()
        return out_dag, tree, cic_count
    else:
       root, children = tree[0], tree[1:]
       mod_child_names = []
       for child in children:
           out_dag, name, cic_count = listToDAGHelper(child, out_dag, cic_count)
           mod_child_names.append(name)
       new_dag = {root: set(mod_child_names)}
       root_new = isShallowSubgraph(new_dag, out_dag)
       if not root_new:
           cic_count[root] += 1
           root_new = root + str(cic_count[root])
           out_dag[root_new] = set(mod_child_names)
    return out_dag, root_new, cic_count

def listToDAG(tree):
    return listToDAGHelper(tree, {}, {constr: 0 for constr in cic_constructors})

def checkEq(d1, d2):
    if d1.keys() != d2.keys():
        return False
    for k in d1:
        if d1[k] != d2[k]: return False
    return True


a = ['App','2','2']
b = ['App','2',a]
c = ['App',b,b]

#utils.ev_4_tree = utils.theoremNameToLists('ev_4', depth=2)

# did we want this (App3)?
assert(checkEq(listToDAG(c)[0],
               {'2': set(), 'App1': {'2'}, 'App2': {'2', 'App1'}, 'App3': {'App2'}}))

assert(checkEq(
        listToDAG(utils.ev_4_tree[1][2])[0],
        {'ev_SS': set(), '2': set(), 'ExportProof.ev_2': set(), 'App1': set(['ev_SS', '2', 'ExportProof.ev_2'])}))

assert(checkEq(listToDAG(['App',['App','2','2'],['App','2','2']])[0],
               {'2': set(), 'App1': {'2'}, 'App2': {'App1'}}))

assert(checkEq(
        listToDAG(['App', ['App', '2', '2'], ['App', '2', ['App', '2', '2']]])[0],
        {'2': set(), 'App1': {'2'}, 'App2': {'App1', '2'}, 'App3': {'App2', 'App1'}}
       ))

#+END_SRC

#+RESULTS:

*** Convert multiple theorems to DAG

#+BEGIN_SRC python :session :results output silent

def toplistToDAG(top_level_theorem, depth=2):
    dag = {}
    cic_count = {constr: 0 for constr in cic_constructors}
    count = 0
    for tree in top_level_theorem[1:]:
        lemma_name, lemma_def = tree[1], tree[2]
        dag, lemma_root, cic_count = listToDAGHelper(lemma_def, dag.copy(), cic_count.copy())
        if count >= 1:
            dag.pop(lemma_name, None)
            for k,v in dag.items():
                if lemma_name in v:
                    dag[k] = {x if x != lemma_name else lemma_root for x in v}
        else:
            theorem_name = lemma_name
        count += 1
    return dag

assert(toplistToDAG(utils.ev_4_tree)
        == {'ev_SS': set(), '2': set(), 'App1': {'2', 'App2', 'ev_SS'}, 'O': set(),
            'ev_0': set(), 'App2': {'ev_0', 'O', 'ev_SS'}})

#+END_SRC

*** Convert library to DAG

#+BEGIN_SRC python :session :results output silent

def libNameToDAG(library_name, depth=2, mod_libs=False, limit=None):
    theorem_dict = utils.libNameToTheoremDict(library_name, depth=depth, mod_libs=mod_libs, limit=limit)
    theorem_tree = ['Top'] + list(map(lambda x:x[1], theorem_dict.values()))
    library_dag = toplistToDAG(theorem_tree)
    return library_dag

#+END_SRC

*** Plot graph utils

#+BEGIN_SRC python :session :results output silent

def plotGraph(graph, outfile, label=False, figsize=(4,4)):
    assert(graph.order() != 0)
    plt.figure(figsize=figsize)
    nx.spring_layout(graph, k=5/math.sqrt(graph.order()))
    nx.draw(graph, with_labels=label, node_size = 50)
    l,r = plt.xlim()
    plt.xlim(l-.2,r+.2)
    plt.savefig(outfile)

def plotUndirected(graph, outfile, label=False, figsize=(4,4)):
    undir_graph = nx.Graph(graph)
    plt.figure(figsize=figsize)
    nx.spring_layout(undir_graph, k=5/math.sqrt(undir_graph.order()))
    nx.draw(undir_graph, with_labels=label, node_size = 20)
    l,r = plt.xlim()
    plt.xlim(l-.2,r+.2)
    plt.savefig(outfile)


def plotGraphs(g1, g2, outfile, label=False, figsize=(4,4)):
    fig, axs = plt.subplots(1,2,figsize=figsize)
    nx.spring_layout(g1, k=5/math.sqrt(g1.order()))
    nx.draw(g1, ax=axs[0], with_labels=label, node_size = 50)
    nx.spring_layout(g2, k=5/math.sqrt(g2.order()))
    nx.draw(g2, ax=axs[1], with_labels=label, node_size = 50)
    range1,range2 = axs[0].get_xlim(), axs[1].get_xlim()
    axs[0].set_xlim(range1[0]-0.2, range1[1]+0.2)
    axs[1].set_xlim(range2[0]-0.2, range2[1]+0.2)
    plt.savefig(outfile)


#+END_SRC

*** Plot theorem DAG's
**** ev_4

#+BEGIN_SRC python :session :results file
theorem_name = 'ev_4'
g = nx.DiGraph(toplistToDAG(utils.ev_4_tree))
plotGraph(g,'./Images/'+theorem_name+'_DAG.png',label=True)
'./Images/'+theorem_name+'_DAG.png'
#+END_SRC

#+RESULTS:
[[file:./Images/ev_4_DAG.png]]

**** ev_8

#+BEGIN_SRC python :session :results file
theorem_name = 'ev_8'
g = nx.DiGraph(toplistToDAG(utils.ev_8_tree))
outfile = './Images/'+theorem_name+'_DAG.png'
plotGraph(g, outfile, label=True)
outfile
#+END_SRC

#+RESULTS:
[[file:./Images/ev_8_DAG.png]]

**** sqrt2_not_rational
***** With libraries

#+BEGIN_SRC python :session :results file
theorem_name, depth, mod_libs = 'sqrt2_not_rational', 2, False
#outfile = './Images/'+theorem_name+'_d'+str(depth)+('_mod_DAG.png' if mod_libs else '_DAG.png')
#tree = utils.theoremNameToLists(theorem_name, depth=depth, mod_libs=mod_libs)
#dag = toplistToDAG(tree)
#plotGraph(nx.DiGraph(dag), outfile, label=True, figsize=(8,8))
outfile
#+END_SRC

#+RESULTS:
[[file:./Images/ev_8_DAG.png]]

***** Without libraries

#+BEGIN_SRC python :session :results file
theorem_name, depth, mod_libs = 'sqrt2_not_rational', 2, True
outfile = './Images/'+theorem_name+'_d'+str(depth)+('_mod_DAG.png' if mod_libs else '_DAG.png')
tree = utils.theoremNameToLists(theorem_name, depth=depth, mod_libs=mod_libs)
dag = toplistToDAG(tree)
plotGraph(nx.DiGraph(dag), outfile, label=True, figsize=(8,8))
outfile
#+END_SRC

#+RESULTS:
[[file:./Images/sqrt2_not_rational_d2_mod_DAG.png]]

**** birthday_paradox

#+BEGIN_SRC python :session :results file
theorem_name = 'birthday_paradox'
outfile = './Images/'+theorem_name+'_DAG.png'
#bday_tree = utils.theoremNameToLists('birthday_paradox', depth=2)
#bday_dag = toplistToDAG(bday_tree, theorem_name)
#plotGraph(nx.DiGraph(bday_dag), outfile, label=False, figsize=(8,8))
'./Images/'+theorem_name+'_DAG.png'
#+END_SRC

#+RESULTS:
[[file:./Images/birthday_paradox_DAG.png]]

** Generate random DAG's with same degree distribution

*** Generate random replica DAG's with same arities

Topological sort
Find pair of edges
Flip if still dag

#+BEGIN_SRC python :session :results output silent

def getNodeIndegrees(theorem_dag):
    indegrees = {k:0 for k in theorem_dag}
    for k in theorem_dag:
        for v in theorem_dag[k]:
            if v in indegrees:
                indegrees[v] += 1
            else:
                indegrees[v] = 1
    return indegrees

def getNodeOutdegrees(dag):
    return {k:len(v) for k,v in dag.items()}

def genComparableGraph(theorem_dag, num_iterations):
    dag = copy.deepcopy(theorem_dag)
    num_nodes = len(dag)
    top_sort = list(nx.topological_sort(nx.DiGraph(dag)))
    node_to_index = {v:i for i,v in enumerate(top_sort)}
    for _ in range(num_iterations):
        e1_end, e2_end = None, None
        while not e1_end:
            e1_start = random.choice(range(num_nodes))
            e1_end_options = list(map(lambda v: node_to_index[v], dag[top_sort[e1_start]]))
            if e1_end_options:
                e1_end = random.choice(e1_end_options)
        while not e2_end:
            e2_start = random.choice(range(e1_end))
            e2_end_options = list(filter(lambda x: x > e1_start,
                                         map(lambda v: node_to_index[v], dag[top_sort[e2_start]])))
            if e2_end_options:
                e2_end = random.choice(e2_end_options)
        #now switch
        dag[top_sort[e1_start]].remove(top_sort[e1_end])
        dag[top_sort[e1_start]].add(top_sort[e2_end])
        dag[top_sort[e2_start]].remove(top_sort[e2_end])
        dag[top_sort[e2_start]].add(top_sort[e1_end])
    assert(nx.is_directed_acyclic_graph(nx.DiGraph(dag)))
    return dag

def genComparableGraphs(theorem_dag, num_iterations, num_graphs):
    return [genComparableGraph(theorem_dag, num_iterations) for _ in range(num_graphs)]

#+END_SRC

*** Plot generated replica DAG's
**** ev_4

#+BEGIN_SRC python :session :results file
outfile = './Images/ev_4_gen_DAG.png'
ev_4_dag = toplistToDAG(utils.ev_4_tree,'ev_4')
gen_ev_4_dag = genComparableGraph(ev_4_dag, num_iterations=100)
plotGraphs(nx.DiGraph(ev_4_dag),
                     nx.DiGraph(gen_ev_4_dag), outfile, label=True, figsize=(6,6))
outfile
#+END_SRC

#+RESULTS:
[[file:./Images/ev_4_gen_DAG.png]]

**** ev_8

#+BEGIN_SRC python :session :results file
outfile = './Images/ev_8_gen_DAG.png'
ev_8_dag = toplistToDAG(utils.ev_8_tree,'ev_8')
gen_ev_8_dag = genComparableGraph(ev_8_dag,num_iterations=10)
plotGraphs(nx.DiGraph(ev_8_dag),
                     nx.DiGraph(gen_ev_8_dag), outfile, label=True, figsize=(8,8))
'./Images/ev_8_gen_DAG.png'
#+END_SRC

#+RESULTS:
[[file:./Images/ev_8_gen_DAG.png]]

**** ev_4_alt

#+BEGIN_SRC python :session :results file
outfile = './Images/ev_4_alt_gen_DAG.png'
ev_4_alt_dag = toplistToDAG(utils.ev_4_alt_tree,'ev_4_alt')
gen_ev_4_alt_dag = genComparableGraph(ev_4_alt_dag)
plotGraphs(nx.DiGraph(ev_4_alt_dag),
                     nx.DiGraph(gen_ev_4_alt_dag), outfile, label=True, figsize=(8,8))

'./Images/ev_4_alt_gen_DAG.png'
#+END_SRC

#+RESULTS:
[[file:./Images/ev_4_alt_gen_DAG.png]]

**** sqrt2_not_rational

#+BEGIN_SRC python :session :results file
theorem_name = 'sqrt2_not_rational'
outfile = './Images/'+theorem_name+'_gen_DAG.png'
tree = utils.theoremNameToLists(theorem_name)
dag = toplistToDAG(utils.sqrt2_tree, 'sqrt2_not_rational')
gen_dag = genComparableGraph(dag, num_iterations=100) #P52 in values but not in keys
plotGraphs(nx.DiGraph(dag),
           nx.DiGraph(gen_dag), outfile, label=False, figsize=(8,8))
outfile
#+END_SRC

#+RESULTS:
[[file:./Images/sqrt2_not_rational_gen_DAG.png]]

*** Export multiple replica DAG's
**** Utils

#+BEGIN_SRC python :session :results output silent


def exportOrigAndReplicas(theorem_dag, theorem_name, num_replicas, num_iterations, depth=2, mod_libs=False):
    outfolder = './ProofDAGs/'+theorem_name+'/'
    if not os.path.exists(outfolder):
        os.mkdir(outfolder)
    orig_out = outfolder+'d'+str(depth)+('_mod.txt' if mod_libs else '.txt')
    with open(orig_out,'w') as f:
        json.dump({k:list(v) for k,v in theorem_dag.items()}, f)
    gen_dags = genComparableGraphs(theorem_dag, num_iterations, num_replicas)
    for i,g in enumerate(gen_dags):
        replica_out = outfolder+'gen_d'+str(depth)+('_mod_' if mod_libs else '_')+str(i)+'.txt'
        with open(replica_out, 'w') as f:
            json.dump({k:list(v) for k,v in g.items()}, f)

def exportReplicas(theorem_name, depth, num_replicas, num_iterations, mod_libs=False):
    outfolder = './ProofDAGs/'+theorem_name+'/'
    theorem_dag = importOrigDAG(theorem_name, depth)
    gen_dags = genComparableGraphs(theorem_dag, num_iterations, num_replicas)
    for i,g in enumerate(gen_dags):
        gen_file = outfolder+'gen_d'+str(depth)+('_mod_' if mod_libs else '_')+str(i)+'.txt'
        with open(gen_file, 'w') as f:
            json.dump({k:list(v) for k,v in g.items()}, f)

def exportDAGs(theorem_name, max_depth, num_replicas, num_iterations, mod_libs=False):
    print('theorem_name:', theorem_name)
    for depth in range(1, max_depth+1):
        tree = utils.theoremNameToLists(theorem_name, depth, mod_libs=mod_libs)
        dag = toplistToDAG(tree, depth=depth)
        exportOrigAndReplicas(dag, theorem_name, num_replicas, num_iterations, depth=depth, mod_libs=mod_libs)

def exportLibDAG(library_name, max_depth, num_replicas, num_iterations, limit=None, mod_libs=False):
    for depth in range(1, max_depth+1):
        dag = libNameToDAG(library_name, depth=depth, mod_libs=mod_libs, limit=limit)
        exportOrigAndReplicas(dag, library_name, num_replicas, depth=depth, mod_libs=mod_libs)

def getGeoCoqTheorems(depth=2, mod_libs=False, limit=None):
    if not os.path.exists('./ProofTrees/euclid_book_d'+str(depth)+'.txt'):
        subprocess.call(['./make_euclid_theorems.sh', str(depth)])
    with open('./ProofTrees/euclid_book_d'+str(depth)+'.txt','r') as f:
        theorem_names = list(map(lambda x:"euclid."+x.strip(), f.readlines()))
    if limit:
        theorem_names = theorem_names[:limit]
    theorems = {}
    return {theorem_name: utils.theoremNameToLists(theorem_name, depth=depth, mod_libs=mod_libs)
         for theorem_name in theorem_names}

def getGeoCoqDAG(depth=2, mod_libs=False, limit=None):
    theorem_dict = getGeoCoqTheorems(depth=depth, mod_libs=mod_libs, limit=limit)
    theorem_tree = ['Top'] + list(map(lambda x:x[1], theorem_dict.values()))
    library_dag = toplistToDAG(theorem_tree)
    return library_dag

def exportGeoCoqDAG(max_depth, num_replicas, limit=None, mod_libs=False, plot=False):
    for depth in range(1, max_depth+1):
        dag = getGeoCoqDAG(depth=depth, mod_libs=mod_libs, limit=limit)
        exportOrigAndReplicas(dag, 'euclid_book', num_replicas, depth=depth, mod_libs=mod_libs, plot=plot)

def geoTreesToDAGs(depth):
    euclid_theorems = list(filter(lambda x: x[:7] == 'euclid.', os.listdir('./ProofTrees')))
    trees = map(lambda x: utils.theoremNameToLists(x, depth=depth), euclid_theorems)
    dags = map(toplistToDAG, trees)
    for theorem_name, dag in zip(euclid_theorems, dags):
        outfile = './ProofDAGs/'+theorem_name+'/d'+str(depth)+'.txt'
        if not os.path.exists('./ProofDAGs/'+theorem_name):
            os.mkdir('./ProofDAGs/'+theorem_name)
        with open(outfile,'w') as f:
            json.dump({k:list(v) for k,v in dag.items()}, f)

#+END_SRC

**** Export All

#+BEGIN_SRC python :session :results output silent

theorem_names = [
  "FTA",
  "Q_countable",
  "pythagoras",
  "Goedel'sIncompleteness1st",
  "Quadratic_reciprocity", # really big
  "Euler_exp_totient",
  "Euler_Poincare_criterion",
  "FTC1",
  "Liouville_theorem",
  "sum_of_two_squares",
  "reals_not_countable",
  "pytha_thm3",
  "CSB",
  "Alt_PI_eq",
  "postulate_of_existence_of_a_triangle_whose_angles_sum_to_two_rights",
  "is_hexamy",
  "bertrand_ballot",
  "Pigeonhole",
  "four_color",
  "Taylor",
  "Cardan_Tartaglia",
  "binomial",
  "Cayley_Hamilton",
  "Wilson",
  "card_powerset",
  #"konigsberg_bridges", # <-- really big
  "herron_qin",
  "Zis_gcd_bezout",
  "Ceva",
  "Strict_Rel_is_Strict_Included",
  "isosceles_conga",
  "fun_power_series_conv_IR",
  "Zgcd_is_gcd",
  "Lagrange",
  "Sylow's_theorem", # big
  "nat_ind",
  "Law_of_the_Mean",
  "Cauchy_Schwarz_inequality",
  "IVT_cor",
  "divisors_correct",
  "div3",
  "Desargues",
  #"edivpP",
  "triangle",
  "birthday_paradox",
  "inclusion_exclusion",
  "mul_adj_mx",
  "Bertrand"
]

#max_depths = [4,3,2,2,2,3,3,2,2,1,None, \
#              None,1, None,None, 2,1,4,1,None,None,None, None,None]

max_depths = [2 for x in theorem_names]
for (theorem_name, max_depth) in zip(theorem_names[9:], max_depths[9:]):
  depth = max_depth if max_depth else 1
  exportDAGs(theorem_name, max_depth=depth, num_replicas=5, num_iterations=10000)

exportDAGs("sqrt2_not_rational", max_depth=2, num_replicas=5, num_iterations=10000)

#library_names = ['Arith']
#for library_name in library_names:
#  exportLibDAG(library_name, max_depth=1, num_replicas=5)
#
#exportGeoCoqDAG(max_depth=1, num_replicas=5, mod_libs=False)

#+END_SRC

**** ev_4

#+BEGIN_SRC python :session :results output silent
theorem_name = 'ev_4'
exportDAGs(theorem_name, max_depth=3, num_replicas=5, num_iterations=10000)
#+END_SRC

**** ev_8

#+BEGIN_SRC python :session :results output silent
theorem_name = 'ev_8'
exportDAGs(theorem_name, max_depth=3, num_replicas=5, num_iterations=10000)
#+END_SRC

**** ev_8_alt

#+BEGIN_SRC python :session :results output silent
theorem_name = 'ev_8_alt'
exportDAGs(theorem_name, max_depth=5, num_replicas=5, num_iterations=10000)
#+END_SRC

** DAG analysis
*** Plotting and Import/Export

#+BEGIN_SRC python :session :results output silent

def plotLineGraph(vals, outfile, figsize=(6,4)):
    fig, axs = plt.subplots(1, 1, sharex = True, figsize=figsize)
    axs.plot(range(len(vals)), vals, 'r+')
    fig.tight_layout()
    plt.savefig(outfile)

def modifiedLog(x):
    return 0 if x == 0 else math.log(x)

def plotLineGraphLogLog(vals, outfile, figsize=(6,4)):
    fig, axs = plt.subplots(1, 1, sharex = True, figsize=figsize)
    axs.plot(list(map(modifiedLog, range(len(vals)))),
             list(map(modifiedLog, vals)), 'r+')
    fig.tight_layout()
    plt.savefig(outfile)

def plotLineGraphs(vals, outfile):
    figsize = (6,3*len(vals))
    fig, axs = plt.subplots(len(vals), 1, sharex = True, figsize=figsize)
    for i in range(len(vals)):
        ax = axs[i]
        ax.plot(range(len(vals[i])), vals[i], 'r+')
    fig.tight_layout()
    plt.savefig(outfile)

def plotLineGraphsLogLog(vals, outfile):
    figsize = (6,3*len(vals))
    fig, axs = plt.subplots(len(vals), 1, sharex = True, figsize=figsize)
    for i in range(len(vals)):
        ax = axs[i]
        ax.plot(list(map(modifiedLog, range(len(vals[i])))),
                list(map(modifiedLog, vals[i])), 'r+')
    fig.tight_layout()
    plt.savefig(outfile)


def importDAG(filename):
    with open(filename,'r') as f:
       return {k:set(v) for k,v in json.loads(f.readline()).items()}

def removeGenVars(dag):
    return {k:{x for x in v if 'gen_var' not in x} for k,v in dag.items() if 'gen_var' not in k}

def importOrigDAG(theorem_name, depth, mod_libs=False):
    filename = './ProofDAGs/'+theorem_name+'/d'+str(depth)+('_mod.txt' if mod_libs else '.txt')
    return importDAG(filename)

def stringifyValues(d):
    return {k:list(map(str, v)) for k,v in d.items()}

def importRandDAGs(theorem_name, depth, mod_libs=False):
    folder_name = './ProofDAGs/'+theorem_name
    search_string = 'gen_d'+str(depth)+('_mod_' if mod_libs else '_')
    filenames = map(lambda y: folder_name +'/'+y,
                    filter(lambda x: search_string in x,
                           os.listdir(folder_name)))
    return list(map(stringifyValues, map(importDAG, filenames)))

#+END_SRC

*** Degree Distributions
**** Definitions

#+BEGIN_SRC python :session :results output silent

def flipDictionary(d):
    unique_vals = set(d.values())
    return {x:set([k for k in d if d[k]==x]) for x in unique_vals}

def getDegreeDist(dag, in_or_out):
    node_degrees = getNodeIndegrees(dag) if in_or_out == 'in' else getNodeOutdegrees(dag)
    degrees_to_nodes = flipDictionary(node_degrees)
    return {k:len(v) for k,v in degrees_to_nodes.items()}

def getOutdegreeDist(dag):
    node_outdegrees = {k:len(v) for k,v in dag.items()}
    outdegrees_to_nodes = flipDictionary(node_outdegrees)
    return {k:len(v) for k,v in outdegrees_to_nodes.items()}

def sparseToDense(d):
    return [d[x] if x in d else 0 for x in range(max(d)+1)]

def getDegreeOrigFileName(theorem_name, depth, in_or_out, mod_libs=False):
    return './Images/'+theorem_name+'_d'+str(depth)+('_mod_' if mod_libs else '_')+in_or_out+'degree_dist.png'

def plotOrigDegreeDist(theorem_name, depth, in_or_out, mod_libs=False):
    dag = importOrigDAG(theorem_name, depth, mod_libs=mod_libs)
    sparse_degree_dist = getDegreeDist(dag, in_or_out)
    degree_dist = sparseToDense(sparse_degree_dist)
    plotLineGraphLogLog(degree_dist, getDegreeOrigFileName(theorem_name, depth, in_or_out, mod_libs=mod_libs))

def sumDicts(d1, d2):
    all_keys = set(d1.keys()).union(set(d2.keys()))
    out = dict()
    for k in all_keys:
        if (k in d1) and (k in d2):
            out[k] = d1[k] + d2[k]
        elif k in d1:
            out[k] = d1[k]
        else:
            out[k] = d2[k]
    return out

assert(sumDicts({'fs':1}, {'fdsa':1, 'fs':2}) == {'fdsa':1, 'fs':3})

def averageDicts(dicts):
    sum_dicts = functools.reduce(sumDicts, dicts, {})
    return {k:v/len(dicts) for k,v in sum_dicts.items()}

def getDegreeRandFileName(theorem_name, depth, in_or_out, mod_libs=False):
    return './Images/gen_'+theorem_name+'_d'+str(depth)+('_mod_' if mod_libs else '_')+in_or_out+'degree_dist.png'

def plotRandDegreeDist(theorem_name, depth, in_or_out, mod_libs=False):
    dags = importRandDAGs(theorem_name, depth)
    degree_dists = list(map(lambda x: getDegreeDist(x, in_or_out), dags))
    sparse_degree_dist_ave = averageDicts(degree_dists)
    plotLineGraphLogLog(sparseToDense(sparse_degree_dist_ave),
                        getDegreeRandFileName(theorem_name, depth, in_or_out, mod_libs=mod_libs))

def estimateBeta(values):
    exp_val_log = sum(map(lambda r: r*math.log(r), values))
    return fsolve(lambda beta: - exp_val_log - digamma(len(values)*beta+1) + digamma(beta+1), 0.5)

def getEntropy(values):
    return -sum(map(lambda r: r*math.log(r), values))

#+END_SRC

**** Examples

#+BEGIN_SRC python :session :results file
theorem_name, depth, in_or_out, mod_libs = 'sqrt2_not_rational', 3, 'in', False
plotOrigDegreeDist(theorem_name, depth, in_or_out, mod_libs=mod_libs)
getDegreeOrigFileName(theorem_name, depth, in_or_out, mod_libs=mod_libs)
#+END_SRC

#+RESULTS:
[[file:./Images/sqrt2_not_rational_d3_indegree_dist.png]]

#+BEGIN_SRC python :session :results file
theorem_name, depth, in_or_out, mod_libs = 'sqrt2_not_rational', 3, 'in', False
plotRandDegreeDist(theorem_name, depth, in_or_out, mod_libs=mod_libs)
getDegreeRandFileName(theorem_name, depth, in_or_out, mod_libs=mod_libs)
#+END_SRC

#+RESULTS:
[[file:./Images/gen_sqrt2_not_rational_d3_indegree_dist.png]]

*** Count number of undirected loops

#+BEGIN_SRC python :session :results output silent

def countNumSimplePaths(dag):
    undir_G = nx.Graph(dag)
    total = 0
    for x in dag:
        total += len(list(nx.all_simple_paths(undir_G, x,x)))
    return total

#+END_SRC

*** Pagerank
**** Utils
#+BEGIN_SRC python :session :results output silent

def getPageRank(dag):
    return nx.algorithms.link_analysis.pagerank(nx.Graph(dag))

def getAveragePageRank(dags):
    return averageDicts(list(map(getPageRank, dags)))

def getSortedRankings(rankings):
    return sorted(rankings.values(), key=lambda x: -x)

def pageRankOrigFileName(theorem_name, depth, mod_libs=False):
    return './Images/'+theorem_name+'_d'+str(depth)+('_mod_' if mod_libs else '_')+'page_rank.png'

def pageRankRandFileName(theorem_name, depth, mod_libs=False):
    return './Images/'+theorem_name+'_d'+str(depth)+('_mod_' if mod_libs else '_')+'gen_page_rank.png'

def plotOrigPageRank(theorem_name, depth, mod_libs=False):
    dag = importOrigDAG(theorem_name, depth, mod_libs=mod_libs)
    rank = getSortedRankings(getPageRank(dag))
    #print("Beta: ", estimateBeta(rank))
    plotLineGraphLogLog(rank, pageRankOrigFileName(theorem_name, depth, mod_libs=mod_libs))

def plotRandPageRank(theorem_name, depth, mod_libs=False):
    dags = importRandDAGs(theorem_name, depth, mod_libs=mod_libs)
    rank = getSortedRankings(getAveragePageRank(dags))
    #print("Beta: ", estimateBeta(rank))
    plotLineGraphLogLog(rank, pageRankRandFileName(theorem_name, depth, mod_libs=mod_libs))

def average(lst):
    return sum(lst)/len(lst)


#+END_SRC

**** Examples
***** sqrt2_not_rational
****** Original

#+BEGIN_SRC python :session :results file
theorem_name, depth = 'sqrt2_not_rational', 3
plotOrigPageRank(theorem_name, depth)
pageRankOrigFileName(theorem_name, depth)
#+END_SRC

#+RESULTS:
[[file:./Images/sqrt2_not_rational_d3_page_rank.png]]

****** Null model

#+BEGIN_SRC python :session :results file
theorem_name, depth = 'sqrt2_not_rational', 3
plotRandPageRank(theorem_name, depth)
pageRankRandFileName(theorem_name, depth)
#+END_SRC

#+RESULTS:
[[file:./Images/sqrt2_not_rational_d3_gen_page_rank.png]]

*** Modularity

#+BEGIN_SRC python :session :results output silent

def getModularity(dag):
    graph = nx.Graph(dag)
    partition = cylouvain.best_partition(graph)
    modularity = cylouvain.modularity(partition, graph)
    return modularity

def getModularitiesFileName(theorem_name, depth, mod_libs=False):
    return './Images/'+theorem_name+'_d'+str(depth)+('_mod_' if mod_libs else '_')+'modularities.png'

def plotOrigVRandModularity(theorem_name, depth, outfile, mod_libs=False):
    orig_modularity = getModularity(importOrigDAG(theorem_name, depth, mod_libs=mod_libs))
    #print("orig modularity: ", orig_modularity)
    rand_modularities = list(map(getModularity, importRandDAGs(theorem_name, depth, mod_libs=mod_libs)))
    plotLineGraph([orig_modularity]+rand_modularities, outfile)

#+END_SRC

***** sqrt2_not_rational

#+BEGIN_SRC python :session :results file
theorem_name, depth, mod_libs = 'sqrt2_not_rational', 2, False
outfile = getModularitiesFileName(theorem_name, depth, mod_libs=mod_libs)
plotOrigVRandModularity(theorem_name, depth, outfile, mod_libs=mod_libs)
outfile
#+END_SRC

#+RESULTS:
[[file:./Images/sqrt2_not_rational_d2_modularities.png]]

***** Elements

#+BEGIN_SRC python :session :results file
theorem_name, depth, mod_libs = 'sqrt2_not_rational', 2, False
outfile = getModularitiesFileName(theorem_name, depth, mod_libs=mod_libs)

tree = json.loads(open('/home/scottviteri/Downloads/elements.txt','r').read())
dag = {x[0]:set(x[1]) for x in tree}
rand_dags = genComparableGraphs(dag, 5)

orig_modularity = getModularity(dag)
#print("orig modularity: ", orig_modularity)
rand_modularities = list(map(getModularity, rand_dags))
plotLineGraph([orig_modularity]+rand_modularities, outfile)

outfile
#+END_SRC

#+RESULTS:
[[file:./Images/sqrt2_not_rational_d2_modularities.png]]

** DAG generative model
*** Create DAG

#+BEGIN_SRC python :session :results output silent

def createGraph(m, p, q, num_iterations):
    d = nx.DiGraph()
    for i in range(num_iterations):
        d.add_node('v'+str(i))
        if m >= d.number_of_nodes():
            maybe_connect = d.nodes()
        else:
            maybe_connect = random.sample(d.nodes(), m)
        for x in maybe_connect:
            if random.random() < p:
                d.add_edge('v'+str(i),x)
                if random.random() < q:
                    for ancestor in nx.algorithms.dag.ancestors(d,x):
                        d.add_edge('v'+str(i),ancestor)
    return {k:set(v) for k,v in nx.convert.to_dict_of_lists(d).items()}

def plotDegreeDist(graph, in_or_out, outfile):
   dist = getDegreeDist(graph, in_or_out)
   plotLineGraph(sparseToDense(dist), outfile)

def plotDegreeDistLogLog(graph, in_or_out, outfile):
   dist = getDegreeDist(graph, in_or_out)
   plotLineGraphLogLog(sparseToDense(dist), outfile)

def exportGenGraph(graph):
    outfile = './ProofDAGs/gen_graph.txt'
    with open(outfile, 'w') as f:
        json.dump({k:list(v) for k,v in graph.items()}, f)

#+END_SRC

*** Plot Graph

#+BEGIN_SRC python :session :results file
graph = createGraph(3,.5,.33,100)
outfile = 'Images/genGraph.png'
plotGraph(nx.DiGraph(graph), outfile)
outfile
#+END_SRC

#+RESULTS:
[[file:Images/genGraph.png]]

*** Plot Degree Distribution

#+BEGIN_SRC python :session :results file
outfile, in_or_out = 'genGraph_degree_dist.png', 'in'
#graph = createGraph(3,.3,.33,7000)
graph = importDAG('./ProofDAGs/gen_graph.txt')
plotDegreeDistLogLog(graph, in_or_out, outfile)
outfile
#+END_SRC

#+RESULTS:
[[file:genGraph_degree_dist.png]]

#+BEGIN_SRC python :session :results file
outfile = './Images/gen_graph_alpha_p_mq.png'

fig = plt.figure()
ax = fig.gca(projection='3d')
#ax.view_init(elev=30.,azim=90)

def f(p,m):
    q = 1.0/m
    graph = createGraph(m,p,q,500)
    degree_dist = list(getDegreeDist(graph, 'in').values())
    alpha = powerlaw.Fit(degree_dist).power_law.alpha
    return alpha

# Make data.
Ps = np.arange(0.05, 1.0, 0.1) # p
Ms = np.arange(1, 10, 1) # m
Xmesh, Ymesh = np.meshgrid(Ps, Ms)
Z = np.array([[f(p,m) for p in Ps] for m in Ms])

# Plot the surface.
surf = ax.plot_surface(Xmesh, Ymesh, Z, cmap=cm.coolwarm,
                       linewidth=0, antialiased=False)

# Customize the z axis.
#ax.set_zlim(-1.01, 1.01)
ax.zaxis.set_major_locator(LinearLocator(10))
ax.zaxis.set_major_formatter(FormatStrFormatter('%.02f'))

# Add a color bar which maps values to colors.
fig.colorbar(surf, shrink=0.5, aspect=5)

plt.savefig(outfile)

outfile
#+END_SRC

#+RESULTS:
[[file:./Images/gen_graph_alpha_p_mq.png]]



*** Export Graph

#+BEGIN_SRC python :session :results output silent
graph = createGraph(3,.3,.33,10000)
exportGenGraph(graph)
#+END_SRC

*** Plot PageRank

#+BEGIN_SRC python :session :results file
#graph = createGraph(3,.3,.33,3000)
graph = importDAG('./ProofDAGs/gen_graph.txt')
p_out = sorted(getPageRank(graph).values())[::-1]
print('beta:',estimateBeta(p_out)[0])
plotLineGraphLogLog(p_out, './Images/gen_graph_pagerank.png')
'./Images/gen_graph_pagerank.png'
#+END_SRC

#+RESULTS:
[[file:./Images/gen_graph_pagerank.png]]

#+BEGIN_SRC python :session :results file
betas = []
for p in map(lambda x:x/50.0, range(1,50)):
    graph = createGraph(3,p,.33,500)
    p_out = sorted(getPageRank(graph).values())[::-1]
    betas.append(estimateBeta(p_out))

plotLineGraph(betas, './Images/gen_graph_beta_v_p.png')
'./Images/gen_graph_beta_v_p.png'
#+END_SRC

#+RESULTS:
[[file:./Images/gen_graph_beta_v_p.png]]

#+BEGIN_SRC python :session :results file
outfile = './Images/gen_graph_beta_p_mq.png'

fig = plt.figure()
ax = fig.gca(projection='3d')
ax.view_init(elev=30.,azim=90)
#
#
#def f(p,m):
#    q = 1.0/m
#    graph = createGraph(m,p,q,500)
#    p_out = sorted(getPageRank(graph).values())[::-1]
#    beta = estimateBeta(p_out)
#    return beta[0]
#
## Make data.
#X = np.arange(0.05, 1.0, 0.05)
#Y = np.arange(1, 20, 1) #m / q (from 1 to 10)
#Xmesh, Ymesh = np.meshgrid(X, Y)
#Z = np.array([[f(x,y) for x in X] for y in Y])
#
# Plot the surface.
surf = ax.plot_surface(Xmesh, Ymesh, Z, cmap=cm.coolwarm,
                       linewidth=0, antialiased=False)

# Customize the z axis.
#ax.set_zlim(-1.01, 1.01)
ax.zaxis.set_major_locator(LinearLocator(10))
ax.zaxis.set_major_formatter(FormatStrFormatter('%.02f'))

# Add a color bar which maps values to colors.
fig.colorbar(surf, shrink=0.5, aspect=5)

plt.savefig(outfile)

outfile
#+END_SRC

#+RESULTS:
[[file:./Images/gen_graph_beta_p_mq.png]]


** Compare Euclid graphs
*** Degree Dists

#+BEGIN_SRC python :session :results output silent

def plotDegreeDistsLogLog(vals, outfile):
    figsize = (6,3*len(vals))
    fig, axs = plt.subplots(len(vals), 1, sharex = True, figsize=figsize)
    for i in range(len(vals)):
        ax = axs[i]
        norm = float(sum(vals[i]))
        ax.plot(list(map(modifiedLog, range(len(vals[i])))),
                list(map(modifiedLog, map(lambda x: x/norm, vals[i]))), 'r+')
        ax.plot(list(map(modifiedLog, range(len(vals[i])))),
                list(map(modifiedLog,
                         map(lambda x: 1.0/((x+1.)*(x+2.)), range(len(vals[i]))))), 'b+')
    fig.tight_layout()
    plt.savefig(outfile)

#+END_SRC

#+BEGIN_SRC python :session :results file
outfile = 'Images/Euclid_compare_indegrees.png'

#g1 = importDAG('./ProofDAGs/euclid_book/d1.txt')
#g_rand = importDAG('./ProofDAGs/euclid_book/gen_d1_0.txt')
#g2 = importDAG('./ProofDAGs/gen_graph.txt')
#g3 = importDAG('./ProofDAGs/euclid_book/euclid_dependencies.txt')

#d1 = sparseToDense(getDegreeDist(g1,'in'))
#d_rand = sparseToDense(getDegreeDist(g_rand,'in'))
#d2 = sparseToDense(getDegreeDist(g2,'in'))
#d3 = sparseToDense(getDegreeDist(g3,'in'))
plotDegreeDistsLogLog([d1,d_rand,d2,d3], outfile)
#plotLineGraphsLogLog([d1,d_rand,d2,d3], outfile)
outfile
#+END_SRC

#+RESULTS:
[[file:Images/Euclid_compare_indegrees.png]]

*** PageRank

#+BEGIN_SRC python :session :results file
outfile = 'Images/Euclid_compare_pagerank.png'

#g1 = importDAG('./ProofDAGs/euclid_book/d1.txt')
#g_rand = importDAG('./ProofDAGs/euclid_book/gen_d1_0.txt')
#g2 = importDAG('./ProofDAGs/gen_graph.txt')
#g3 = importDAG('./ProofDAGs/euclid_book/euclid_dependencies.txt')

#p1 = sorted(getPageRank(g1).values())[::-1]
#p_rand = sorted(getPageRank(g_rand).values())[::-1]
#p2 = sorted(getPageRank(g2).values())[::-1]
#p3 = sorted(getPageRank(g3).values())[::-1]
#print("Betas:", list(map(estimateBeta,[p1,p_rand,p2,p3])))
plotLineGraphsLogLog([p1,p_rand,p2,p3], outfile)
outfile
#+END_SRC

#+RESULTS:
[[file:Images/Euclid_compare_pagerank.png]]

*** Modularity

#+BEGIN_SRC python :session :results output silent
outfile = 'Images/Euclid_compare_modularity.png'

#g1 = importDAG('./ProofDAGs/euclid_book/d1.txt')
#g_rand = importDAG('./ProofDAGs/euclid_book/gen_d1_0.txt')
#g2 = importDAG('./ProofDAGs/gen_graph.txt')
#g3 = importDAG('./ProofDAGs/euclid_book/euclid_dependencies.txt')

# too big
m1 = getModularityFast(g1)
#m_rand = getModularity(g_rand)
#m2 = getModularity(g2)
#m3 = getModularity(g3)

#print(m1, m_rand, m2, m3)
#+END_SRC

*** All Statistics

#+BEGIN_SRC python :session :results output silent

def getProofStatistics(theorem_name, depth):
    theorem_dag = importDAG('./ProofDAGs/'+theorem_name+'/d'+str(depth)+'.txt')
    degree_dist = list(getDegreeDist(theorem_dag, 'in').values())
    alpha = powerlaw.Fit(degree_dist).power_law.alpha
    pagerank_dist = sorted(getPageRank(theorem_dag).values())[::-1]
    beta = estimateBeta(pagerank_dist)[0]
    modularity = getModularity(theorem_dag)
    #generated_graph = importDAG('./ProofDAGs/gen_graph.txt')
    #gen_modularity = getModularity(generated_graph)
    return {'theorem_name':theorem_name,'depth':depth,
            'alpha':alpha,'beta':beta,'modularity':modularity}

def exportStatistics(stats):
    outfolder = './ProofStatistics/'+stats['theorem_name']+'/'
    if not os.path.exists(outfolder):
        os.mkdir(outfolder)
    with open(outfolder+'d'+str(stats['depth'])+'.txt','w') as f:
        json.dump(stats, f)

#+END_SRC

#+BEGIN_SRC python :session :results output silent
theorem_name, depth = 'sqrt2_not_rational', 1
print(getProofStatistics(theorem_name, depth))
#+END_SRC

#+BEGIN_SRC python :session :results output silent
theorem_name, depth = 'sqrt2_not_rational', 3
exportStatistics(getProofStatistics(theorem_name, depth))
#+END_SRC

#+BEGIN_SRC python :session :results output silent
depth = 2
for theorem_name in theorem_names[4:]:
    print('theorem_name:',theorem_name)
    exportStatistics(getProofStatistics(theorem_name, depth))
#+END_SRC
